<!doctype linuxdoc system>

<article>

<title>The KDE Daemon
<author>Simon Hausmann
<htmlurl url="mailto:hausmann@kde.org" name="<hausmann@kde.org>">
<date>v1.0 26, June 1999
<abstract>
This documentation describes the KDE Daemon, the services it provides and
how to use it. So if you're dealing with <idx/CORBA server/s in the KDE or if you're
interested in a smart way of accessing <idx/KService/ data in your application then
you might want to read this and use <cdx/kded/

<toc>

<sect>Introduction

<p>
The KDE Daemon, herein simply named <cdx/kded/, is a central daemon in the KDE Desktop
Environment. It provides three services:

<itemize>
<item>The KDE Trader (<cdx/KTrader/) , which provides an easy-to-use but still extremly
      powerful interface to the KDE Registry.
<item>The KDE Activator (<cdx/KActivator/) , which makes accessing CORBA based services
      in KDE the easiest thing of the world ;-) .
<item>The KDE Naming Service (<cdx/KNaming/) , which provides a simple but useful
      naming service for CORBA Objects.
</itemize>

<sect>Using The KDE Daemon In Your Application

<p>
Before we can use any of <cdx/kded/'s services, we have to know something about it's
"position" in the KDE and the way it itself and the services can be accessed.


As <cdx/kded/ uses CORBA to communicate with it's clients, your application (as client),
has to
<itemize>
<item>link to the <cdx/kded/ library, <cdx/libkded/.
<item>link to libmico
<item>initialize the <idx/MICO/ <idx/ORB/
</itemize>


The first two points are fixed for all clients, the third one depends on the
specific client. In general you have to choices:

<itemize>
<item>If your application already uses <idx/KOM/, then you're fine with using
      <cdx/KOMApplication/ (as you need it anyway) .
<item>If you don't want to use <idx/KOM/, then you can initialize the ORBA "manually":
<verb>
CORBA::ORB_ptr orb = CORBA::ORB_init( argc, argv, "mico-local-orb" );
</verb>
Please note that when using this construct or similar ones, your application is
<bf>not</bf> able to act as <idx/CORBA server/ if you are using KDE/Qt classes at the
same time. This is due to the fact that the <idx/ORB/ needs it's own event loop, beside
the main Qt event loop. Currently only <cdx/KOMApplication/, as part of the KDE Object
Model, implements the needed functionality to combine both event loops and thus
making KDE apps able to serve CORBA Objects.
</itemize>


Although <cdx/kded/ uses CORBA extensively, the API is kept simple and free from
complicated CORBA stuff. In fact when talking about <cdx/kded/ and it's API not the
<cdx/kded server/ is meant but the KDE Daemon library. This library contains the
interface to the server (for the clients) as well as the whole server functionality.
The reason for this is based on the idea that an application using <cdx/kded/ should
not be forced to rely on an existing <cdx/kded server/ binary nor a running server at
all. The following three situations may exist when a client app gets started:

<itemize>
<item>No <cdx/kded/ is running and there's no <cdx/kded server/ binary in the path. In this
      situation <cdx/libkded/ will automatically start a local instance of <cdx/kded/ in
      the application's process.
<item>No <cdx/kded/ is running but there's a <cdx/kded server/ binary available. Here <cdx/libkded/
      will start the kded executable and connect to it.
<item><cdx/kded/ is already running :-) . The fact that a <cdx/kded/ is running is indicated
      by a special property on the X Root Window. <cdx/kded/ publishes it's <idx/IOR/
      (Interoperable Object Reference) in this property. This also ensures that
      a <idx/kded/ instance is specific to a X display and therefore to your KDE session.
</itemize>

To sum it up: <idx/libkded/ will always make sure that the services of <idx/kded/ are available
for your client application, no matter in what alien environment the app is 
running :-) . And, although you don't have to care about this, you can optionally
control this behaviour of <idx/libkded/ by adding one of the following three <idx/commandline arguments/
to your app:
<itemize>
<item>"-kdedlocal" , which will make <idx/libkded/ <bf>always</bf> start a process-local
      instance of kded and it's services.
<item>"-kdedremote" , which will make <idx/libkded/ try to look for a running <idx/kded/
      instance before starting a local one.
<item>"-kdedior ior_here" , which will make <idx/libkded/ connect to the <idx/kded server/
      specified by the given <idx/IOR/.
</itemize>


Your actual interface to <idx/kded/ and it's services is the <tt><cdx/KdedInstance/</tt> class,
defined in kded_instance.h . So if you want to use <idx/kded/ (I guess that's why you're
reading this shit ;) ) then make sure to create <bf>one</bf> single instance
of it, preferably by adding the following line somewhere in the beginning of
your <tt>main()</tt> :
<verb>
KdedInstance( argc, argv, _a_reference_to_the_orb_here_ );
</verb>
If you're using <idx/KOMApplication/ as application object (make sure to create the
instance before this line) , then you're fine by specifying <tt>komapp_orb</tt> as
reference to the <idx/ORB/.


As there is always only one single instance of this class, you can simply access
it by the static <tt><cdx/self()/</tt> method of the class from anywhere you want. No
need to pass <cdx/KdedInstance/ arguments all around in your program ;-) .


For further information about <tt><cdx/KdedInstance/</tt> you might want to read
<tt/<cdx/kded_instance.h// , it's pretty good documented.

<sect><idx/KTrader/

<p>
As already mentioned in the introduction, <idx/KTrader/ gives you access to the registry.
"Now what the hell is the registry?" you might ask. As this is just a documentation
about <idx/kded//<idx/libkded/, I can only respond: "Please consult the documentation of/in
<tt/<cdx/libkio// for more information" :-} . Just one thing about it here: <idx/KTrader/ loads
the whole and bloaty registry for you. Thanks to the magic of <tt/<cdx/libkio// the loaded
registry will always be in sync with the "real" registry, the <idx/.desktop/ files in
the following standard directories (both types, the system wide and the user ones) :
<itemize>
<item>applnk
<item>mimelnk
<item>services
<item>servicetypes
</itemize>


Now over to <idx/KTrader/ and it's API. Similar to <tt><cdx/KdedInstance/</tt> there can
be only one single instance. The difference is that you don't have to care
about allocating it, just simply get a reference to the <idx/KTrader/ by calling
the <tt>ktrader()</tt> method of <tt><cdx/KdedInstance/</tt> . And: don't
even think about deleting the returned reference! Just simply use it and be
happy with it :-) . (hey, <idx/kded/ is designed to be easy to use, no need for difficult
stuff...)


The <idx/KTrader/ API is even so simple that it contains only two methods ;-) . But
before I describe these methods you have to know something about the kind of
data <idx/KTrader/ returns. In simple words: You will always get a list of <idx/KService/
objects. More detailed: The returned list is a <tt><cdx/QValueList/</tt> and the
entries are <tt><cdx/KSharedPtr/</tt>'s (FIXME: will soon be renamed to QSharedPtr,
as it will become part of Qt.... AFAIK) to <tt><idx/KService/</tt> objects. Please
read the corresponding Qt documentation about these two classes. The big advantage
of using these two template classes is that everything becomes easy for you
and that the memory consumption is kept at a minimum . You don't have to care 
about pointers, freeing them and cleaning up the list, as long as you use 
<tt><cdx/KTrader::ServicePtr/</tt> variables to hold the <idx/KService/ objects and as
long as you use <tt><cdx/KTrader::OfferList/</tt> to pass the list around in your
program. So: Remember to always use these two types when dealing with <idx/KTrader/!

Now over to the two methods.


<tt><cdx/KTrader::listServices()/</tt> returns your a list of <bf>all</bf> available
services in the whole KDE. (no need for further explanations I think...)

<tt><cdx/KTrader::query()/</tt> is the key method of this beast. It performs a lookup
in the registry database, given your information about what you want to have.
The first argument is the name of the servicetype which all returned services
must implement. If you're unsure about the word "servicetype" , then you can
replace it with "mimetype" , for most, but not all, cases.

The second argument is an additional constraint expression, which has to be
fulfilled by a service.

The third argument is a preference expression after which the returned services
will be sorted. The value of the expression has to be numeric.

The syntax of these two expressions is equal to the language of the standard
CORBA Trader (this is due to the fact that the parsing code is from the <idx/COS/
Trader of <idx/MICO/) . The language is not very difficult and I don't want to bloat
this documentation with further explanations about it. Please consult your
CORBA literature for more information. Just one thing you have to know:
Comparisons are always done with the properties of the <idx/KService/ object,
which are the standard entries (Name, ServiceType, RepoIds, ...) plus
the ones specified in the servicetype declaration and read by <idx/KService/.

Well, after so much theoretical explanations it's time for some practical example
code:
<ncdx/KTrader::OfferList/
<verb>
  ...
  //get a reference to the KTrader
  KTrader *trader = KdedInstance::self()->ktrader();
  
  ...
  //will return a list of all services which implement the servicetype
  //named "text/plain"
  KTrader::OfferList offers = trader->query( "text/plain" );
  

  ...
  //will return a list of all services which implement the servicetype
  //named "image/gif" and which have the AllowAsDefault property set true
  KTrader::OfferList offers = trader->query( "image/gif", "AllowAsDefault == TRUE" );
  
  ...
  //will return KSpread ;-)
  KTrader::OfferList offers = trader->query( "KOfficeDocument", "(Exec == 'kspread') and (Path != '/opt/gnome/bin')" );
  
  ...
  //will return a list of all services which implement the servicetype
  //named "BlahFoo" and which will be sorted (from lowest to highest) by 
  //the value of the property "Price" , declared in the servicetype 
  //declaration of BlahFoo.
  KTrader::OfferList offers = trader->query( "BlahFoo", QString::null, "min Price" );
</verb>


Please note that <idx/KTrader/, since it queries <tt/<cdx/libkio// for services, will
always return services sorted by the user's preferences for the specific 
servicetype. These preferences can be specified in the file "profilerc" .

<sect1>KTraderServiceProvider

<p>
This section requires to be familiar with <tt/<cdx/libkio// and it is meant for everybody who
wants to use <idx/KRun/ in his application.

<idx/KRun/ requires a fully loaded registry in order to resolve mimetype <-> application
bindings. A fully loaded registry means that you need a <tt/<cdx/KServiceTypeFactory// and
a KServiceFactory, which both load the appropriate <tt/<cdx/KServiceType//<tt/<cdx/KService// objects.
Now the KServiceType information doesn't need that much memory, but the <idx/KService/
object really eat loooots of it. And isn't it kind of stupid to load this information
if this is already done by <idx/kded/? Yes, it is ;-) .


What we would need is to make <idx/KRun/ query <idx/KTrader/ for <idx/KService/ data, instead of
directly using <idx/KServiceTypeProfile/. Fortunately <idx/KRun/ is flexible enough for this,
we just need a re-implementation of the <idx/KServiceProvider/, defined in <tt/<cdx/krun.h//
and used by <idx/KRun/. Guess what, but <idx/KTrader/ provides you this re-implementation :-) .
Just have a look at the end of <tt/<cdx/ktrader.h//.


To sum it up: The following line makes <idx/KRun/ query <idx/kded/, in your application:
<verb>
  ...
  //place this somewhere BEFORE the first usage of KRun, preferable somewhere
  //in main()
  KTraderServiceProvider serviceProvider;
  ...
</verb>
That's all, except that you <bf>must</bf> have a <cdx/KdedInstance/ in order to be
able to use it.

<sect><idx/KActivator/

<p>
One often mentioned problem, when talking about applications which provide
their services via CORBA, is how to start and access these services. Solutions
like making apps write the <idx/IOR/ of an object somewhere into a file in the
filesystem or similar approaches are just hacks ;-) . Better use <idx/KActivator/,
since it can automatically, on demand, start servers for you or use already 
running ones. This is accomplished with the help of the mediators for <idx>BOA/POA</idx>
and the <idx/IMR/ (Implementation Repository), both provided by <idx/MICO/. Fortunately
you don't have to deal with IMR entries and the mediators.


Before you can use <idx/KActivator/ to start a server for you, you have to register
the server's service. There are two possible ways, the last one is highly
recommended though:

<itemize>
<item>Register and unregister it manually, by using the two corresponding
      methods of the <idx/KActivator/.
<item>Go the smart way and provide the necessary information in a <idx/.desktop/ file.
      Fortunately <idx/KService/ supports the necessary properties, like repository
      ids, activation mode and others.
</itemize>


For the second point it's important that the <idx/.desktop/ file is available for
<idx/KRegistry/, by placing it in a directory which gets scanned by the registry.
If your application has already a <idx/.desktop/ file in the applnk tree for example,
then you're fine with adding the necessary fields in there. Otherwise the
directory named "services" (either system-wide or user-local) is the best place 
for it. If you provide the CORBA service information this way, then <idx/KActivator/
will automatically detect it and register it automatically at the IMR. This 
means that it is immediately available for <idx/KActivator/ and thus to your client app.
And since <idx/KRegistry/ is such a cool thing :-) , you can do all this even at
run-time, when <idx/kded/ is running. Just place the <idx/.desktop/ file in one of the
right directories for it and <idx/KActivator/ will update the IMR on-the-fly. The
same applies obviously for just deleted or modified <idx/.desktop/ files, which will
make <idx/KActivator/ adjust the IMR. Now you might get the idea why this is the
preferred way :-)) .


Now that you know how to register CORBA services you will want to know how
to "access" it. <tt>activateService()</tt> is your friend here. Simply pass
it the name of the service, the repository id of the server object and the
object's tag and it will return you a functional object reference. That's all :-)


Depending on the service's activation mode, <idx/KActivator/ will either return a reference
to an already running server or it will start a new instance.


One note about the returned object reference: This is a virtual reference,
which means that that server object is started when the first call is invoked
on this reference, thus making your server get started "lazy", only on-demand.
But that's just additional information, you don't have to deal and know about
it at all. Just be happy with your functional object reference :-) .


Want some examples? Here we go:

This is how a <idx/.desktop/ file could look like, assuming that the commandline
"--server" starts the app in <idx/CORBA server/ mode:
<verb>
Name=MyApp
Exec=fooblah
CORBAExec=fooblah --server
X-KDE-RepoIds=IDL:Foo/Blah:1.0#MyFoo
X-KDE-ActivationMode=shared
</verb>


If <idx/KActivator/ "gets" this file, it will register the service and then you're
able to do something like this:
<verb>
  ...
  KActivator *activator = KdedInstance::self()->kactivator();
  ...
  CORBA::Object_var obj = activator->activateServer( "MyApp", "IDL:Foo/Blah:1.0", "MyFoo );
  ...
</verb>


The above example will either start a new fooblah instance or connect to a running
one.

For further information please have a look at the examples in kdelibs/corba/tutorials/kded .
The example application there registers the server manually via <tt>registerService</tt> .

Please note: The server <bf>has</bf> to be started by <idx/kded/ in order to make <idx/KActivator/
return a reference to a running one. Executing "fooblah" from somewhere else
will <bf>not</bf> make <idx/KActivator/ use it. This is a problem for persistent
servers like <idx/KDesktop/ for example. But there's a solution available, just read
the next chapter about the KDE Naming Service :-) .

<sect><idx/KNaming/

<p>
The KDE Naming Service, <idx/KNaming/, is also a very simple service, but it's pretty
useful and in some cases a very nice solution to make a CORBA client connect to
a persistent <idx/CORBA server/.


With <idx/KNaming/ you can bind a freely chooseable name to a CORBA object. And since
<idx/kded/ is system (session) wide available, your object becomes available for any
client which is able to connect to <idx/kded/.


There's not much to explain here :-} , so I suggest having a look at the <idx/KNaming/
API, in <tt/<cdx/knaming.h//.


Example code can be, again, found in kdelibs/corba/tutorials/kded . Here's just
a short real example situation:


Just think of <idx/KDesktop/, that nice app providing your background desktop icons.
It provides some functionality via CORBA, just have a look at kdesktop.idl to
see what I'm talking about. Now the problem for <idx/KDesktop/ is: How can it provide
this service to other apps in the system? Writing an <idx/IOR/ into some file is no
clean solution IMHO, and using <idx/KActivator/ doesn't work because <idx/KDesktop/ does not
get started by <idx/kded/ but by the startkde script on KDE startup. So we find a better
way and make <idx/KDesktop/ register it's object at <idx/KNaming/. This is done by the following
lines:
<verb>
  ...
  KNaming *knaming = KdedInstance::self()->knaming();
  naming->bind( "KDesktop", kdesktop_object_here );
  ...
</verb>
Well, I told you a lie ;) : <idx/KNaming/ does not really bind to "<idx/KDesktop/" but
instead to "IDL:KDesktopIf:1.0" , but since there's no naming convention
for the naming I have choosen a more readable name, IMHO of course :-) (don't
mind me David :] ) . I personally prefer human readable names ;) , in contrary 
to repository ids with tags.


Back to <idx/KNaming/ and <idx/KDesktop/: Now any client application, kfmclient for example,
can "connect" to <idx/KDesktop/. Just like this:
<verb>
  ..
  KNaming *knaming = KdedInstance::self()->knaming();
  ...
  CORBA::Object_var obj = knaming->resolve( "KDesktop" );
  KDesktopIf_var kdesky = KDesktopIf::_narrow( obj );
  kdesky->selectAll(); //let's confuse the user by selecting all icons ;-)
  ...
</verb>


</article>


