<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Using KOM / OpenParts HOWTO: OpenParts</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="KDE KOM OpenParts CORBA MICO">
<META NAME="description" CONTENT="KOM/OpenParts Documentation">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.gif" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

Next <A HREF="index-2.html">Previous</A>
 <A HREF="index.html#toc3">Table of Contents</A>
</P>
<H3><A NAME="s3">3. OpenParts</A></H3>

<P>
<P>
<H3><A NAME="ss3.1">3.1 Introduction</A>
</H3>

<P>
<P>The goals of the OpenParts technology, based upon KOM, are:
<UL>
<LI>provide an easy way to graphically embed other application's "widgets"</LI>
<LI>provide an clever way to manage shared GUI elements and provide a CORBA/KOM
interface/implementation of these</LI>
<LI>implement the basic support for the document view model</LI>
</UL>
<P>To simplify the act of understanding OpenParts I will give a short example
situation:
<P>Imagine you have an a word processor and a formula editor, both being separate
applications. If you now want to insert a formula into your word processor
document by using your formula editor application this arises several
problems: You can of course embed the formula editor's main widget window via
swallowing by using XReparentWindow and friends, or easier by using QXEmbed.
But then how do you want to edit your formula without having access to the
formula editor's menubar / toolbar? In any way it would look ugly if these are
part of the formula window. Wouldn't it be nice if the menus / toolbars of
your word processor application would get replaced by the formula editor ones,
except for some general menu /toolbar items? And when you go back to your text
document the old menus / toolbars come back again.
<P>Well, this is a perfect job for OpenParts :-) .
<P>OpenParts solves the above described problem by introducing a new sytem of
visual components and a new way of creating shared GUI elements, such as menus
or toolbars, dynamically on demand.
<P>In the implementation of OpenParts every element consists usually of two
classes, the interface implementation, where the class name ends with "If",
and the Qt/KDE object. So for example the OpenParts StatusBar element is
represented by two classes: <CODE>OPStatusBar</CODE>, being derived from
KStatusBar,  handles the Qt/KDE specific extensions, and
<CODE>OPStatusBarIf</CODE> which is  responsible for providing an implementation
of the actual OpenPartsUI::StatusBar  interface by "translating" the interface
functionality into Qt/KDE function  calls.
<P>Since every Qt/KDE object in OpenParts is most often bound to such an
interface, like described above, there is usually an interface() function
which returns a reference to the OpenParts interface of the element. In case
of the above example <CODE>OPStatusBar::interface()</CODE> returns a reference to
an <CODE>OPStatusBarIf</CODE> object which is directly bound to this
<CODE>OPStatusBar</CODE> object.
<P>
<H3><A NAME="ss3.2">3.2 OPApplication</A>
</H3>

<P>
<P>Similar to KOMApplication, the class OPApplication (derived from
KOMApplication) is required when using OpenParts.
<P>
<H3><A NAME="ss3.3">3.3 QWidget as Component? - the OpenParts::Part interface</A>
</H3>

<P>
<P>In OpenParts every window which has its own GUI and which is meant to be
displayed in a MainWindow is called a Part (just like the formula editor view
or the word processor document view in the above described example) , and
implements the OpenParts::Part interface by deriving from the class
<CODE>OPPartIf</CODE>.
<P>If you want to make a widget class a full-featured Part component then you
have to handle some things different than you might be used to, in regard to
the standard Qt/KDE widget framework. In fact now a widget is no more a simple
window in which you display some data, no, a Part is much more than this. In
particular a Part has, beside it's window (widget, which may of course contain
sub-windows or even other Parts (see <CODE>OPFrame</CODE> documentation) ) a
full-featured GUI, consisting of a menubar with menus, toolbar(s) and a
statusbar.
<P>The special thing with the GUI is the way it is created, handled/used and
"destroyed" . All this has to be highly dynamic because now the user decides
about which Part he wants to have active. OpenParts provides the basic
framework for this:
<UL>
<LI>it tells you when you have to create your GUI and provides you the necessary
references to the GUI related objects of OpenParts.</LI>
<LI>it also tells you when the GUI is destructed.</LI>
<LI>in addition you are notified when your Part gets the focus and gives you
the choice whether to accept or reject the focus.</LI>
<LI>you are also notified when your Part gets registered to a MainWindow, in
order to register your component at several GUI servant objects, just
like the menubar manager for example.</LI>
</UL>
<P>The very first step you have to make is to tell the OpenParts Part Interface
(<CODE>OPPartIf</CODE>) , the class you have to inherit from, what the actual
widget is, because <CODE>OPartIf</CODE> does not inherit from QWidget. This gives
you the  flexibility to separate your Part component from your actualy widget,
but you  don't have to do this. You can simply multiply inherit from
<CODE>OPPartIf</CODE> and QWidget or the appropriate widget class. In any way you
specify your Part  widget by calling <CODE>setWidget( your_widget_here )</CODE> .
In most cases, when  the Part component is the widget at the same time, you
simply call <CODE>setWidget( this )</CODE> :-) . Make sure this call is done in
the constructor of your class!
<P>The next important point is that you will want to re-implement the virtual
<CODE>init()</CODE> function of <CODE>OPPartIf</CODE> . This is highly recommended
since this function is called after your Part got registered by a MainWindow.
The idea  behind this function is that at the time the constructor of a Part
gets executed, the Part itself is definitely not registered to a MainWindow,
yet. But in fact you need to know when your Part gets registered, in order to
register your Part at the GUI servant objects, which are only available via
the MainWindow's interface. A reference to the MainWindow is available through
the <CODE>m_vMainWindow</CODE> variable, which will be automatically initialized
when the MainWindow  registration is done, so don't use this variable before
your <CODE>init()</CODE> function gets called (<CODE>m_vMainWindow</CODE> will be nil
anyway) .
<P>Now over to the details of the <CODE>init()</CODE> function. Here you should place
all initialisation stuff which depends on being registered to a MainWindow.
In addition you can do the above mentioned registration at the GUI managing
objects. Usually this looks like the following example:
<PRE>
void MyPart::init()
{
  //register at the menubar manager if you want to use/display a menubar
  OpenParts::MenuBarManager_var menuBarManager = m_vMainWindow->menuBarManager();
  if ( !CORBA::is_nil( menuBarManager ) ) //check whether the shell window allows us to have a menubar
    menuBarManager->registerClient( id(), this ); //see chapter about the
              //*barManager objects
              //for further explanations

  //...the same with the toolbar
  OpenParts::ToolBarManager_var toolBarManager = m_vMainWindow->toolBarManager();
  if ( !CORBA::is_nil( toolBarManager ) )
    toolBarManager->registerClient( id(), this );

  //better define a class wide variable, of course
  OpenPartsUI::StatusBar_var m_vMyStatusBar;

  OpenParts::StatusBarManager_var statusBarManager = m_vMainWindow->statusBarManager();
  if ( !CORBA::is_nil( statusBarManager ) )
    m_vMyStatusBar = statusBarManager->registerClient( id() );
}
</PRE>
<P>Note that the registration calls for these three GUI element types are only
necessary if you really want to use them. For example if your Part does not
want to display any toolbar you should leave out the corresponding call.  In
addition you might come up with the situation that for example the
<CODE>toolBarManager()</CODE> call returns a nil reference, which indicates that
the MainWindow does not allow its Parts to have a toolbar. Obviously the same
applies for the menubar and the statusbar.
<P>OpenParts makes use of KOM events to tell a Part about the
construction/destruction of it's GUI. These are in particular:
<UL>
<LI><CODE>OpenPartsUI::eventCreateMenuBar</CODE> ("OpenPartsUI/CreateMenuBar")</LI>
</UL>

The attached argument is a <CODE>OpenPartsUI::MenuBar</CODE>
<P>
<UL>
<LI><CODE>OpenPartsUI::eventCreateToolBar</CODE> ("OpenPartsUI/CreateToolBar")</LI>
</UL>

The attached argument is a <CODE>OpenPartsUI::ToolBarFactory</CODE>
<P>Depending on whether a Part wants to display a menubar and/or toolbar, the
managing objects emit these two events to it. In regard to your implementation
this means that you have to re-implement the <CODE>event()</CODE> function
(remember: A Part is a full-featured KOM Component) .
<P>The attached event arguments indicate whether the toolbar(s) or the menubar
are to be created or cleared. Check these arguments against
<CODE>CORBA::is_nil()</CODE> and you know :-) .
<P>The OpenParts StatusBar is handled different compared to the
MenuBar/ToolBar(s) . In fact it is easier: When registering at the OpenParts
StatusBarManager you receive your <CODE>OpenParts::StatusBar</CODE> as return
value. You can then use the StatusBar everywhere in your Part, independend
>from whether it is visible (active) or not.
<P>In the <CODE>init()</CODE> function a lot of registration stuff is done, and
corresponding to this in the <CODE>cleanUp()</CODE> function (see chapter about
KOM::Base) you have to unregister from the GUI servant objects and free all
appropriate references, following KOM's model of symmetric references and
connections. Usually the code looks like this:
<PRE>
void MyPart::cleanUp()
{
  if ( m_bIsClean )
    return;

  //unregister our menubar
  OpenParts::MenuBarManager_var menuBarManager = m_vMainWindow->menuBarManager();
  if ( !CORBA::is_nil( menuBarManager ) )
    menuBarManager->unregisterClient( id() );

  //...the same with the toolbar
  OpenParts::ToolBarManager_var toolBarManager = m_vMainWindow->toolBarManager();
  if ( !CORBA::is_nil( toolBarManager ) )
    toolBarManager->unregisterClient( id() );

  OpenParts::StatusBarManager_var statusBarManager = m_vMainWindow->statusBarManager();
  if ( !CORBA::is_nil( statusBarManager ) )
    statusBarManager->unregisterClient( id() );

  //free other references here
  //...

  //this is IMPORTANT!!!
  //Always call the cleanUp() method of the base class when you're done!
  OPPartIf::cleanUp();
}
</PRE>
<P>
<H3><A NAME="ss3.4">3.4 Part Children</A>
</H3>

<P>
<P>A Part Child is a usual Part with three extra features:
<OL>
<LI>A Part Child has a Parent Part assigned.</LI>
<LI>It does not have a GUI and it therefore does not receive any GUI creation
events.</LI>
<LI>The Parent Child receives events whenever there are any child related focus
changes. Since the Part Child functionality is integrated in the
<CODE>OpenParts::Part</CODE> interface and it's implementation,
<CODE>OPPartIf</CODE>, you don't have to deal  with additional classes when
using Child Parts. Simply leave out the mapping of the OpenParts GUI
events in the Child Part and instead map the Child Part events described
below and assign the Parent Part via <CODE>setParent()</CODE>. See the
interface description of <CODE>OpenParts::Part</CODE> , in openparts.idl,
for further information about the events and the API in general.</LI>
</OL>
<P>
<H3><A NAME="ss3.5">3.5 How to embed a Part - the OPFrame class</A>
</H3>

<P>
<P>Now that you know how to create full-featured Part components it is still
unexplained how Parts are really displayed/shown. Since Parts are no simple
QWidgets but CORBA objects we need a helping hand here, which is the
<CODE>OPFrame</CODE> class. In fact <CODE>OPFrame</CODE> is a QWidget, but in
conjuction with Qt's QXEmbed it embeds the Part's widget window. The usage of
<CODE>OPFrame</CODE> is really easy, usually the code looks like this:
<P>
<PRE>
... somewhere in an application's widget ...
myFrame = new OPFrame( the_parent_widget );
myFrame->attach( a_reference_to_the_part_we_want_to_embed );
myFrame->show();
</PRE>
<P>In addition to the above example you can <CODE>detach()</CODE> your Part, which
you should usually do on exit. Just have a look at opFrame.h , it is
documented.
<P>
<P>One last important thing you have to know about <CODE>OPFrame</CODE> is that this
class internally uses KOM referencing (using a <CODE>KOMVar</CODE> variable) to
hold the Part.  This means that there are two possible situations when using
<CODE>OPFrame</CODE> :
<P>
<UL>
<LI>If the embedding Widget/Object uses KOM referencing as well to keep a
reference to the Part then there are two objects influencing the Part's
lifecycle. On the one hand there's the <CODE>OPFrame</CODE> which
increases/decreases the Part's KOM reference counter when it gets
attached/detached, and on the other hand there's the embedding
Widget/Object. So make sure that you know when you free your KOM
reference to the Part in regard to detaching the Part!</LI>
<LI>If the embedding Widget/Object does not use KOM referencing then you have
to know that when detaching the Part it automatically gets destroyed,
since usually the <CODE>OPFrame</CODE> is the only object holding a KOM
reference  to the Part and the KOM reference counter therefore drops
down to zero and issues the complete destruction of the object.</LI>
</UL>
<P>
<H3><A NAME="ss3.6">3.6 The center of OpenParts - the OpenParts::MainWindow interface</A>
</H3>

<P>
<P>Another important component is the so called OpenParts::MainWindow, being
derived from a KTMainWindow in the implementation (and therefore the top-level
window of your application) and being the shell around visible sub-windows and
shared GUI elements.
<P>The MainWindow's functionality is extended by some builtin aggregates, the
managing objects for the menu-/tool-/statusbar. These objects are either
available directly via the <CODE>*barManager()</CODE> methods of the MainWindow's
interface or indirectly by being aggregates and therefore available via the
components interface repository (<CODE>getInterface()</CODE>,
<CODE>supportsInterface()</CODE>, ...) .
<P>A Part can only be displayed in a MainWindow and the MainWindow has to know
about this. So before you can display a Part you have to register it to the
MainWindow. This is done by calling the Part Interface's
<CODE>setMainWindow()</CODE> method (see previous chapter for further information
about the process of registration) and this will give the Part a unique ID
(which is for example used when addressing the part's GUI via the *bar manager
objects) .
<P>The MainWindow, as shell, has full control over all shared GUI elements.  This
means that it is responsible for
<UL>
<LI>creating the appropriate *bar managing objects</LI>
<LI>providing a skeleton/standard GUI which is meant to be always present,
no matter what Part is active</LI>
<LI>telling the GUI managing objects to activate/deactivate a Part's GUI</LI>
</UL>
<P>The creation of the *bar managers can be easily done by simply performing a
dummy call to <CODE>*barManager()</CODE> which usually returns a pointer to the
appropriate manager and also creates a new one if it does not exist yet. It is
recommended to perform these calls in the constructor of your MainWindow.
<P>The creation/handling of the skeleton GUI is explained later in the chapters
about OPMenu(Bar)/OPToolBar .
<P>Your MainWindow emits a Qt signal (<CODE>activePartChanged</CODE>) which informs
you about a focus change of the active part, meaning whenever the user clicks
on a non-active Part and it accepts the focus. Beside the pure informative
sense  of this signal it is recommended to connect to this signal and perform
the  following two steps in the slot implementation:
<P>
<OL>
<LI>deactivate the previous active Part's GUI by calling the *bar managers
<CODE>clear()</CODE> function, which will do the job and, beside some
internal stuff, emit the GUI events (see previous chapter) to the Part.</LI>
<LI>activate the new active Part's GUI by calling the *bar managers
<CODE>create()</CODE> function, which will, similar to the activation, emit
events to the Part. This is not really required but it is highly
recommended. The following code is usually used for this:

<PRE>
      void NameOfYourMainWindow::slotActivePartChanged( unsigned long old_id,
                                                        unsigned long new_id )
      {
        // clear the menu/tool/statusbar(s)
        menuBarManager()->clear();
        toolBarManager()->clear();
        statusBarManager()->clear();
        // create the new Part's GUI
        menuBarManager()->create( new_id );
        toolBarManager()->create( new_id );
        statusBarManager()->create( new_id );
      }
      
</PRE>
</LI>
</OL>
<P>Now that the MainWindow handles all the shared "stuff" there is one thing
which was not mentioned in this documentation, yet: What about the
MainWindow's caption? The OpenParts MainWindow interface allows parts to have
their own window captions, but how does OpenParts handle this?
<P>Well, there are two ways:
<OL>
<LI><CODE>OPMainWindow</CODE> provides you a so called <CODE>AutoCaption</CODE> mode
which automatically changes the MainWindow's caption whenever the active
part changes. This is enabled by default.</LI>
<LI>But sometimes the shell wants to have full control over the window's
caption, and this is accomplished by disabling the <CODE>AutoCaption</CODE>
mode, which  leads to the situation that the window's caption is not
changed by OpenParts  in any way but instead gives you control over it.</LI>
</OL>
<P>
<H3><A NAME="ss3.7">3.7 Access shared GUI elements through CORBA - OpenPartsUI and its interfaces</A>
</H3>

<P>
<P>Well, now that we know when we have to construct/destruct a Part's GUI,
via the OpenPartsUI events, we have to learn how to really create it, because
we don't have the common KMenuBar, KToolBar, etc. classes anymore available.
The replacement for them are CORBA Objects, described in openparts_ui.idl which
is, together with the corresponding implementations, a part of the partsui
module. The interfaces are 98%; similar to the KDE/Qt classes, so they're
quite easy to use. Instead of bloating up this documentation with example code
I rather suggest reading the tutorials in kdelibs/corba/tutorials .
<P>
<H3><A NAME="ss3.8">3.8 Pixmaps and Strings in OpenParts - OPUIUtils</A>
</H3>

<P>
<P>Toolbars and menus are usually beautified with pixmaps, using QPixmap classes.
As we now use a CORBA interface to access our GUI elements, QPixmap has become
OpenPartsUI::Pixmap for OpenParts applications. OpenPartsUI::Pixmap is just
a "stringified" QPixmap, and opUIUtils.(h,cc) contains some easy
to use conversion routines.
<P>In addition OPUIUtils contains string conversion routines between CORBA::WChar*
and QString. This is necessary since Qt version >=2.0 supports Unicode,
via QString, all over the place, and obviously GUI elements like menus or
toolbars have been converted to support this. OpenParts has been converted,
too, by using "wstring" (CORBA::WChar *) in the interfaces and by
using and providing conversion routines. These routines are static member
functions of the OPUIUtils  class, just like with the pixmap conversion. To
simplify the usage, two macros have been defined: <CODE>Q2C</CODE> and
<CODE>C2Q</CODE> . The first one converts a QString into a CORBA::WChar * string
and the second one vice-versa.
<P>When converting from QString to CORBA::WChar * the conversion routine
allocates memory. To avoid memory leaks it is highly recommended to use
CORBA::WString_var variables. Exactly the same applies for QPixmap ->
OpenPartsUI::Pixmap conversions: Use OpenPartsUI::Pixmap_var , and you don't
have to worry about leaks :-) .
<P>Here's some example code, to show how to do it right:
<PRE>
    ...
    OpenPartsUI::Pixmap_var pm = OPUIUtils::convertPixmap( QPixmap_variable_here );
    someToolBar->insertButton( pm, ... );
    ...
    //use the same pm variable again
    pm = OPUIUtils::convertPixmap( another_qpixmap );
    ...
</PRE>
<P>Similar things have to be done with QString's:
<P>
<PRE>
  
    ...
    CORBA::WString_var text = Q2C( QString_here );
    someMenuBar->insertItem7( text, ... );
    ...
    // or you can write:
    someMenuBar->insertItem7( ( text = Q2C( QString_here ) ) , ...);
    ...
</PRE>
<P>One note left: When you return a "wide string" (CORBA::WChar *) as
a function result by using <CODE>Q2C</CODE>, make sure not to use
<CODE>CORBA::wstring_dup()</CODE>.
<P>Example:
<PRE>
  
  return CORBA::string_dup( Q2C( QString_here ) ); //!!!! WRONG!!!!!
  ...
  return Q2C( QString_here ); // RIGHT! because Q2C already allocates the string
</PRE>
<P>That's it! Have fun using KOM/OpenParts :-)
<P>TODO:
<UL>
<LI>KOMShutdownManager</LI>
<LI>AutoLoader template classes</LI>
<LI>OPApplication Interface + Factories</LI>
</UL>
<P>
<P ALIGN="RIGHT">

Next <A HREF="index-2.html">Previous</A>
 <A HREF="index.html#toc3">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
