<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Using KOM / OpenParts HOWTO: The KDE Object Model (KOM)</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="keywords" CONTENT="KDE KOM OpenParts CORBA MICO">
<META NAME="description" CONTENT="KOM/OpenParts Documentation">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#aa0000" TEXT="#000000" > 
<FONT FACE="Helvetica">
<A HREF="http://www.kde.org/"><IMG SRC="logotp3.gif" BORDER="0" ALT="The K Desktop Environment"></A>
<HR WIDTH="100%" SIZE=2 ALIGN="CENTER" NOSHADE>

 
<P ALIGN="RIGHT">

<A HREF="index-3.html">Next</A>
 <A HREF="index-1.html">Previous</A>
 <A HREF="index.html#toc2">Table of Contents</A>
</P>
<H3><A NAME="s2">2. The KDE Object Model (KOM)</A></H3>

<H3><A NAME="ss2.1">2.1 First ways of communication - the KOM::Base interface</A>
</H3>

<P>The Base interface and its implementation in <CODE>libkom</CODE> provide the basic
functionality for a standardized communication between CORBA objects using
KOM. This includes
<P>
<UL>
<LI>signals and slots, similar to the mechanism used in the Qt toolkit</LI>
<LI>event handling, including filtering</LI>
<LI>relatives management</LI>
<LI>reference counting</LI>
</UL>
<P>
<H3><A NAME="ss2.2">2.2 Signals and Slots</A>
</H3>

<P>KOM supports signals and slots just like in the Qt toolkit, with a few
differences in usage and implementation. The first and biggest difference is
that signals and slots are no more typesafe again, meaning there's no moc
compiler generating meta data for KOM signals/slots to enable type checking at
run-time, when connecting.
<P>Another difference is the way you declare signal and slot functions. Signals
have to be declared with the <CODE>SIGNAL_IMPL</CODE> macro from <CODE>komBase.h</CODE>,
without  specifying any signal arguments. Slot methods have to be defined in
your CORBA  interface description.
<P>For KOM signals the equivalent to the "emit" keyword from Qt is the
<CODE>SIGNAL_CALLx</CODE> macro, were "x" is one of 0, 1, 2, depending on the
number of arguments.
<!--
KOM::Base
-->

Example:
<P>In your CORBA interface description:
<PRE>
  #include &lt;kom.idl&gt;

  interface FooSender : KOM::Base
  {
    signal void mySignal( in long foobaz );
  };

  interface FooReceiver : KOM::Base
  {
    slot void mySlot( in long gosh );
  };
</PRE>
<P>In the implementation of FooSender:
<PRE>
  FooSender_Impl::FooSender_Impl( ... )
  {
    ...
    SIGNAL_IMPL( "mySignal" );
    ...
  }

  FooSender_Impl::mySignal( CORBA::Long foobaz )
  {
    SIGNAL_CALL1( "mySignal", foobaz );
  }
</PRE>
<P>In the implementation of FooReceiver:
<PRE>
  FooReceiver_Impl::mySlot( CORBA::Long gosh )
  {
    ...
  }
</PRE>
<P>First some words about the sender: It is not required to define the signal
in the interface description and to provide an implementation which simply
emits the signal. However in many cases this is recommended, because this makes
it easier for other developers to use your interface because they aren't required
to seek in the implementation sources just to find out about the signals this
object emits. Another way is to simply document the existence of the signal
in the interface description, without defining a method. From the technical
point only the <CODE>SIGNAL_CALLx</CODE> macro counts when emitting the signal.
<P>What's left is connecting and disconnecting. In the above described example it
could like this:
<PRE>
  ...
  SenderObject->connect( "mySignal", ReceiverObject, "mySlot" );
  ...
  SenderObject->disconnect( "mySignal", ReceiverObject", "mySlot");
</PRE>
<P>Well, this is quite self-explaining I think. Just make sure to always disconnect
from your object upon destruction.
<P>
<H3><A NAME="ss2.3">2.3 Events</A>
</H3>

<P>
<P>An event consists of two elements, the event name, being a string, and an
event argument, being a CORBA::Any value and therefore freely choosable by the
developer.
<P>Events, sent to a specified object, can be imagined as being put through a
pipe until they reach the destination object. This "pipe" is filled with
installed  event filters. There are three kinds of filters.
<UL>
<LI>reading filters ( <CODE>FM_READ</CODE> )</LI>
<LI>writing filters ( <CODE>FM_WRITE</CODE> )</LI>
<LI>implementing filters ( <CODE>FM_IMPLEMENT</CODE> )</LI>
</UL>
<P>In the current implementation in KOM these filter modes only specify the order
how the event is processed. When an event is emitted it gets first filtered by
all event filters with the filter mode <CODE>FM_WRITE</CODE>, then followed by
<CODE>FM_IMPLEMENT</CODE> and finally by <CODE>FM_READ</CODE>. Event filters have two
possibilities what they can do with the actual event: They can just
<B>read</B> it or they can <B>discard</B>  it, which means the event is
discarded and will never receive its destination  object.
<P>The actual event name has a special meaning in regard to event filters.  When
installing an event filter to an object you have to specify, beside a
reference to the filter object and the name of the filter mapping function, a
sequence of so called event type patterns. An event type pattern can be the
name of a  single event as well as a special pattern (see <CODE>kom.idl</CODE> for more
information about event type patterns) .
<P>When an event is meant to be processed by a filter, the specified filter
function gets called, with the event name and the event value as arguments.
This filter function has to return (through a boolean value) whether the event
should be discarded or not.
<P>When all filtering is done and none of the installed filters discarded the
event, it is finally received by the destination object, by calling the
object's <CODE>event()</CODE> method, defined in the KOM::Base interface. The default
implementation does actually nothing, so you may want to re-implement this
virtual function.
<P>The very low-level usage of events is to call the receive/receiveASync methods
of an object for sending an event and to re-implement KOMBase::event for
mapping an event. But KOM provides some nice macros which simplify the
processing of events.
<P>
<H4>Sending Events</H4>

<P>
<P>For sending komBase.h defines some useful <CODE>EMIT_EVENT</CODE> macros, all
using the same syntax:
<PRE>
EMIT_EVENT_x( destination_object, event_name, event_argument)
</PRE>
<P>"destination_object" is a reference to the object which is meant to
receive/process the event. The event will be filtered through all event
filters which are installed in this destination object. "event_name" is
self-explaining ;-) . The event argument depends on the specific macro, which
are in particular:
<P>
<UL>
<LI><CODE>EMIT_EVENT</CODE>, the general macro for sending. The event argument is
required to have a <CODE>&lt;&lt;=</CODE> operator for CORBA::Any defined. You
will want to use this macro whenever the event argument is a structure
for example. (and don't forget to compile your idl file with the "--any"
option, so that the idl compiler generates the necessary operator
methods)</LI>
<LI><CODE>EMIT_EVENT_BOOLEAN</CODE>, useful for boolean event arguments. The
only difference to the <CODE>EMIT_EVENT</CODE> macro is that it uses
CORBA::Any::from_boolean for you to convert the boolean value. So it
doesn't really matter whether you use:

<PRE>
    EMIT_EVENT( receiver, name, CORBA::Any::from_boolean( value ) );
</PRE>

or
<PRE>
    EMIT_EVENT_BOOLEAN( receiver, name, value );
</PRE>

</LI>
<LI><CODE>EMIT_EVENT_OCTET</CODE>, similar to EMIT_EVENT_BOOLEAN, useable for
CORBA::Octet values.</LI>
<LI><CODE>EMIT_EVENT_CHAR</CODE>, similar to EMIT_EVENT_BOOLEAN, useable for char
(CORBA::Char) values.</LI>
<LI><CODE>EMIT_EVENT_WCHAR</CODE>, similar to EMIT_EVENT_BOOLEAN, useable for
CORBA::WChar values.</LI>
<LI><CODE>EMIT_EVENT_STRING</CODE>, similar to EMIT_EVENT_BOOLEAN, useable for
char * (CORBA::Char*) values.</LI>
<LI><CODE>EMIT_EVENT_WSTRING</CODE>, similar to EMIT_EVENT_BOOLEAN, useable for
CORBA::WChar* values.</LI>
<LI><CODE>EMIT_EVENT_OBJECT</CODE>, similar to EMIT_EVENT_BOOLEAN, useable for
CORBA objects (CORBA::Object).</LI>
</UL>
<P>
<H4>Receiving Events</H4>

<P>
<P>The process of receiving events is a little bit more difficult, compared
to sending, since we have to process all kinds of events an object can receive
in one handler method, KOM::Base::event (IDL) / KOMBase::event (C++) . Just
like with sending events you can again do everything on low CORBA level, but
why should we go the hard way? KOM again provides very nice and easy-to-use
macros for this (defined in komBase.h) :-) . Usually all this looks like the
following example:
<!--
KOM::Base
-->

<PRE>
#include &lt;kom.idl&gt;

module MyModule
{
  // we say: the event argument is a string
  const string eventFirstFoo = "MyFooEventNameOrWhateverYouNameIt";

  struct MyStruct
  {
    boolean kde_rules;
  };

  const string eventSecondFoo = "Blaafooo";
  typedef MyStruct EventSecondFoo;

  interface SomethingElse
  {
    //..
  };

  const string eventThirdFoo = "KOMIsCool";
  typedef SomethingElse EventThirdFoo;

  interface Foo : KOM::Base
  {
    //...
  };

};

bool FooImpl::event( const char *event, const CORBA::Any &amp;value )
{
  EVENT_MAPPER( event, value );

  MAPPING_STRING( MyModule::eventFirstFoo, mappingFirstFoo );

  MAPPING( MyModule::eventSecondFoo, MyModule::EventSecondFoo, mappingSecondFoo );

  MAPPING( MyModule::eventThirdFoo, MyModule::EventThirdFoo_ptr, mappingThirdFoo );

  END_EVENT_MAPPER; //the macro executes "return false;" for us, to indicate that
                    //we did not handle the event if we reach this point
}

bool FooImpl::mappingFirstFoo( const char *myArgument )
{
  ...
  //don't forget to return with a boolean value, indicating whether you sucessfully
  //processed the event or not.
}

bool FooImpl::mappingSecondFoo( MyModule::MyString anotherArg )
{
  //...
}

bool FooImpl::mappingThirdFoo( MyModule::SomethingElse_ptr whaaboo )
{
  //...
}
</PRE>
<P>As you can see an event handler usually begins with the <CODE>EVENT_MAPPER</CODE>
macro and ends with <CODE>END_EVENT_MAPPER</CODE> . Similar to the
<CODE>EMIT_EVENT_x</CODE> macros, the <CODE>MAPPING</CODE> macros consist of a general
<CODE>MAPPING</CODE> macro and the following friends:
<UL>
<LI><CODE>MAPPING_BOOLEAN</CODE></LI>
<LI><CODE>MAPPING_OCTET</CODE></LI>
<LI><CODE>MAPPING_CHAR</CODE></LI>
<LI><CODE>MAPPING_WCHAR</CODE></LI>
<LI><CODE>MAPPING_STRING</CODE></LI>
<LI><CODE>MAPPING_WSTRING</CODE></LI>
<LI><CODE>MAPPING_OBJECT</CODE></LI>
</UL>
<P>In order to structurize the process of event handling a little bit, every
event  gets its own event handling function. These functions are called by the
mapping  macros (last argument) . The above used naming scheme is not a
requirement,  however it is used in most applications using KOM.
<P>
<H3><A NAME="ss2.4">2.4 Adopting</A>
</H3>

<P>
<P>You should use adopting whenever you want to hold a reference to an object and
want to be informed when the object dies in order to free all your references
to this object. But this should only be used when you're not the parent
object, meaning you didn't reference the object directly via the KOM reference
counter.  When using adopting you should re-implement the <CODE>leaveNotify</CODE>
(and perhaps <CODE>adoptNotify</CODE>) methods of your  object (and don't forget
to call the original KOMBase method!) .
<P>
<H3><A NAME="ss2.5">2.5 KOM referencing</A>
</H3>

<P>
<P>KOM reference counting should be used to "express" that you possess the
object. This gives you direct control over the lifecycle of the object by
letting the reference counter act directly on the server object, in contrary
to CORBA reference counting, where the reference counter only acts on the stub
object, in case of remote objects (this is different for local objects, where
stub = server object) . When the KOM reference counter drops down to zero the
object gets destroyed. This destruction is done by calling <CODE>cleanUp()</CODE>,
which closes all connections to other objects and leaves all relatives.  After
this call is finished the object truly gets released. You might want to
re-implement the <CODE>cleanUp()</CODE> method. In this case make sure that you
don't forget two things:
<P>
<UL>
<LI>only execute if the boolean variable <CODE>m_bIsClean</CODE> is false,
otherwise simply return</LI>
<LI>make sure you call the previous implementation!</LI>
</UL>
<P>As a short summary to this KOM reference stuff just keep in mind, that
there are three ways to hold a reference to an object:
<UL>
<LI>you're connected to the object via signals/slots or via event filters</LI>
<LI>you're the parent object, meaning you hold a reference through the KOM
reference counter</LI>
<LI>otherwise you should use adopting to get informed whenever the object wants
to die, in order to free all references to the object which are not of
one of the above kinds. The idea behind all this is that all
connections/references between objects are symmetric, meaning
<B>both</B> sides know about the connection and <B>both</B> sides
clean up all connections between each other whenever one of the two
objects wants to die. In case of signal/slot connections this is done
automatically by KOM. In case of KOM reference counters you have the
direct control over the lifecylcle for the object. Adopting, as third
way, can be used to keep other connections symmetric, connections which
are neither signal/slot connections nor direct references via the KOM
reference counter.</LI>
</UL>
<P>Hint: Using the <CODE>KOMVar</CODE> template makes handling KOM references much
easier, they can be used similar to the CORBA _var types.
<P>
<H3><A NAME="ss2.6">2.6 THE component - the KOM::Component interface</A>
</H3>

<P>The Component interface, being derived from the Base interface, additionally
provides a kind of small interface repository for only this component,
combined with the possibility to provide new interfaces by dynamic aggregation
and a standard way to add plugin components. This gives CORBA objects the
possibility to enhance their functionality at run-time.
<P>There are five kinds of interfaces:
<UL>
<LI>Builtin Interfaces (derived Interfaces)</LI>
<LI>Builtin Aggregate Interfaces</LI>
<LI>Dynamic Aggregate Interfaces</LI>
<LI>Builtin Plugin Interfaces</LI>
<LI>Dynamic Plugin Interfaces</LI>
</UL>
<P>Builtin interfaces are all interfaces the object directly implements. This
means they are part of the actual object implementation and can be specified
via the <CODE>ADD_INTERFACE</CODE> macro (in komComponent.h) . So for example if
your interface description looks like this:
<PRE>
module Foo
{
  interface MyInterface : AnotherInterface
  {
    ...
  };
};
</PRE>
<P>You should add the following line into the constructor of an implementation of
this interface:
<!--
IDL
-->

<PRE>
ConstructorNameOfMyInterface::ConstructorNameOfMyInterface( ... )
{
  ...
  ADD_INTERFACE( "IDL:Foo/MyInterface:1.0" );
  ...
}
</PRE>
<P>This way you tell your component that it supports the interface
"Foo/Interface" and therefore makes it available through the three functions
<CODE>getInterface()</CODE>, <CODE>interfaces()</CODE> and
<CODE>supportsInterface()</CODE> .
<P>
<H3><A NAME="ss2.7">2.7 Extend your component by aggregation - KOM::Aggregate</A>
</H3>

<P>
<P>Aggregates solve a problem with distributed objects, the problem of
derivation.  Since the implementation of an interface is completely
encapsulated there has to be another way to extend the functionality of an
already existing  object.  By using aggregate components you can add new
interfaces to an object,  at run-time. This means you extend the functionality
but you do not change the behaviour of the object itself.
<P>
<H4>Builtin Aggregates</H4>

<P>
<P>Builtin aggregate interfaces are the interfaces of aggregate implementations
which run in the same process as our component. See in komComponent.h the four
functions of the <CODE>KOMComponent</CODE> class for adding builtin aggregates,  it's easy.
<P>
<H4>Dynamic Aggregates</H4>

<P>
<P>Dynamic aggregates are similar to builtin aggregates, with two differences:
<P>
<UL>
<LI>They can (are) be installed from "outside" of the component,
using  AggregateFactories (see kom.idl) . This way they do neither have
to run  within the same process nor on the same computer.</LI>
<LI>They can depend on other available interfaces. KOM does the job of resolving
these dependencies for you.</LI>
</UL>
<P>
<H3><A NAME="ss2.8">2.8 Plugins - the KOM::Plugin interface</A>
</H3>

<P>
<P>Plugins are the kind of counterpart to aggregates. They do not extend the
functionality of an object by providing new interfaces, but instead usually
change the behaviour of it, by
<OL>
<LI>doing things like installing event filters to the object, etc.</LI>
<LI>providing special plugin interfaces</LI>
</OL>
<P>
<H3><A NAME="ss2.9">2.9 Collect your components - the KOM::Container interface</A>
</H3>

<P>
<P>Containers do something simple but extremly useful: They act as repository for
Container members. A container member structure consists of two elements:
<P>
<UL>
<LI>the member name, a freely chooseable and unique string identifier</LI>
<LI>the member object, a KOM::Base type You can add, remove, replace, list
and lookup container members or just clear  the whole container. In
addition the container emits signals whenever a  member has been added
or removed.</LI>
</UL>
<P>
<H3><A NAME="ss2.10">2.10 Factories</A>
</H3>

<P>
<P>KOM contains two abstract factory interfaces:
<OL>
<LI>KOM::AggregateFactory</LI>
<LI>KOM::PluginFactory</LI>
</OL>
<P>They both serve the job of creating objects and are needed for the creation of
dynamic plugin and aggregate components. Whenever you want to install a such a
dynamically created object to a component you have to provide an
implementation of a factory interface.
<P>
<H3><A NAME="ss2.11">2.11 KOMApplication</A>
</H3>

<P>
<P>KOMApplication is the drop-in replacement for KApplication, required when
using CORBA in your KDE Application. It, internally, combines CORBA event
handling with Qt event handling and initializes the ORB and the BOA on
startup.  komApplication.h defines two smart macros to get a reference to the
ORB/BOA: <CODE>komapp_orb</CODE> and <CODE>komapp_boa</CODE> . Usually you will want
to use your own application class, derived from KOMApplication, and
re-implement <CODE>start()</CODE> and/or <CODE>restore()</CODE> , which will be called
>from <CODE>KOMApplication::exec()</CODE>, depending on the BOA's state about
restoring objects. For further information about KOMApplication's API see
komApplication.h .
<P>
<P ALIGN="RIGHT">

<A HREF="index-3.html">Next</A>
 <A HREF="index-1.html">Previous</A>
 <A HREF="index.html#toc2">Table of Contents</A>
</P>
<CENTER>
<HR WIDTH="100%" SIZE=3 ALIGN=CENTER NOSHADE>
</CENTER>    
</FONT>

 
</BODY>
</HTML>
