/*
 *  Opcode data structure and selection routines for KJS/Frostbyte
 *  This file is part of the KDE libraries
 *  Copyright (C) 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include "opcodes.h"
#include <cstdio>

namespace KJS {

const int Cost_NoConversion = -100000; // small enough so that adding actual costs doesn't
                                       // make it positive
const int Cost_Checked      = -2;

@generate

// Note: costOut will be Cost_NoConversion if no conversion is possible
static ConvOp computeCast(const OpValue* in, OpType outType, bool outImmediate, int& costOut)
{
    bool   inImmediate = in->immediate;
    OpType inType      = in->type;

    // Can't make a register result into an an immediate value,
    // and there is no reason ever to convert immediate to register, since
    // we will always have a specialization
    if (outImmediate != inImmediate) {
        costOut = Cost_NoConversion;
        return Conv_NoConversion;
    }

    // Look up in the table..
    const ConvInfo* inf = getConversionInfo(inImmediate, inType, outType);
    if (inf->costCode == Cost_Checked) {

        ASSERT(outType == OpType_value);

        if (inType == OpType_uint32) {
            if (JSImmediate::from(in->value.narrow.uint32Val))
                costOut = 0;
            else
                costOut = Cost_NoConversion;
        } else {
            ASSERT(inType == OpType_number);
            if (JSImmediate::from(in->value.wide.numberVal))
                costOut = 0;
            else
                costOut = Cost_NoConversion;
        }

        return inf->routine;
    }

    costOut = inf->costCode;
    return inf->routine;
}

static void emitConversion(CompileState* comp, CodeBlock& block,
                           ConvOp convType, OpValue* original, OpValue& out)
{
    if (original->immediate) {
        emitImmediateConversion(convType, original, out);
        return;
    }

    OpValue registerAddr;

    switch (convType) {
    case Conv_NoOp:
        out = *original;
        break;
    case Conv_RBool_Uint32:
        // This one's a no-op..
        out = *original;
        break;
    case Conv_RBool_Value: {
        out    = comp->requestTemporary(OpType_value);
        regNum = comp->regNum(out);
        emitOp(comp, block, Op_JsBoolean, &regNum, original);
    }
    break;

    case Conv_RValue_Bool: {
        out    = comp->requestTemporary(OpType_bool);
        regNum = comp->regNum(out);
        emitOp(comp, block, Op_ToBoolean, &regNum, original);
    }
    break;

    case Conv_RValue_Uint32: {
        out    = comp->requestTemporary(OpType_uint32);
        regNum = comp->regNum(out);
        emitOp(comp, block, Op_ToUInt32, &regNum, original);
    }
    break;

    case Conv_RUint32_Bool: {
        out    = comp->requestTemporary(OpType_bool);
        regNum = comp->regNum(out);
        emitOp(comp, block, Op_UInt32ToBool,  &regNum, original);
    }
    break;

    case Conv_RUint32_Value: {
        out    = comp->requestTemporary(OpType_value);
        regNum = comp->regNum(out);
        emitOp(comp, block, JSNumberFromUInt32, &regNum, original);
    }
    break;

    default:
        CRASH();
    };
    // ### TODO
}

OpByteCode* CodeGen::emitOp(CompileState* comp, CodeBlock& block, OpName baseInstr,
                            OpValue* a0, OpValue* a1, OpValue* a2)
{
    static const Op* const* cands = opSpecializations[baseInstr];

    const Op* cheapest = 0;
    int    cheapestCost = 0;
    ConvOp cheapestConvOps[3] = {Conv_NoConversion, Conv_NoConversion, Conv_NoConversion};

    int numArgs = 0;
    if (a0)
        numArgs = 1;
    if (a1)
        numArgs = 2;
    if (a2)
        numArgs = 3;

    // First, scan through, and determine the cheapest non-align variant.
    // We can't select whether to align or not, since we may have to emit
    // cast ops, which could change where we are.
    for (int c = 0; cands[c]; ++c) {
        const Op* cand = cands[c];
        ASSERT(cand->numParams == numArgs);

        if (cand->padAlign)
            continue;

        int    cost0 = 0, cost1 = 0, cost2 = 0;
        ConvOp convOps[3];

        switch (numArgs) {
        case 3:
            convOps[2] = computeCast(a2, cand->paramTypes[2], cand->immediateParams[2], cost2);
        case 2:
            convOps[1] = computeCast(a1, cand->paramTypes[1], cand->immediateParams[1], cost1);
        case 1:
            convOps[0] = computeCast(a0, cand->paramTypes[0], cand->immediateParams[0], cost0);
        }

        int totalCost = cand->cost + cost0 + cost1 + cost2;

        if (totalCost < 0) // Cost_NoConversion in the sum...
            continue;

        if (totalCost < cheapestCost || !cheapest) {
            cheapest        = cand;
            cheapestCost    = totalCost;
            cheapestConvOps[0] = convOps[0];
            cheapestConvOps[1] = convOps[1];
            cheapestConvOps[2] = convOps[2];
        }
    }

    if (!cheapest)
        CRASH(); // Should never happen!

    OpValue c0, c1, c2; // Converted versions, if needed.

    switch (numArgs) {
    case 3:
        emitConversion(block, cheapestConvOps[2], a2, c2);
    case 2:
        emitConversion(block, cheapestConvOps[1], a1, c1);
    case 1:
        emitConversion(block, cheapestConvOps[0], a0, c0);
    case 0:
        break;
    }

    // Now figure out if we need to do align.. We need it if the PC is 8-aligned, since
    // the instr will mess that up, and the instruction need it..
    if (cheapest->hasPadVariant && ((block.size() % 8) == 0)) {
        // The padded variant of the instruction always preceeds the unpadded one..
        cheapest = &opsForOpCodes[cheapest->opCode - 1];
    }

    // Phewww. Now we can actually write out stuff.
    size_t pos = block.size();
    block.resize(pos + cheapest->length);
    unsigned char* basePtr = block.data() + pos;
}

static void dumpParam(CodeBlock& block, size_t offset, OpType type)
{
    switch (type) {
    case OpType_bool:
        if (reinterpret_cast<NarrowArg*>(block.data() + offset)->boolVal)
            std::printf("true");
        else
            std::printf("false");
        break;
    case OpType_uint32:
        std::printf("%d", reinterpret_cast<NarrowArg*>(block.data() + offset)->uint32Val);
        break;
    case OpType_value:
        std::printf("huh???");
        break;
    case OpType_ident:
        std::printf("%s", reinterpret_cast<WideArg*>(block.data() + offset)->identVal->ustring().ascii());
        break;
    case OpType_addr:
        std::printf("A%8x", reinterpret_cast<NarrowArg*>(block.data() + offset)->addrVal);
        break;
    case OpType_reg:
        std::printf("r%d", reinterpret_cast<NarrowArg*>(block.data() + offset)->regVal);
        break;
    default:
        std::printf("???");
    };
    std::printf(" ");
}

void CodeGen::disassembleBlock(CodeBlock& block)
{
    size_t pc = 0;
    while (pc < block.size()) {
        OpByteCode opCode = *reinterpret_cast<OpByteCode*>(block.data() + pc);
        const Op& opDescr = opsForOpCodes[opCode];

        std::printf("%8x %s ", pc, OpNameVals[opDescr.baseInstr]);
        for (int p = 0; p < opDescr.numParams; ++p) {
            dumpParam(block, pc + opDescr.paramOffsets[p],
                      opDescr.immediateParams[p] ? opDescr.paramTypes[p] : OpType_reg);
        }

        std::printf("// %s\n", OpByteCodeVals[opCode]);
        pc += opDescr.length;
    }
}

} //namespace KJS
// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;
