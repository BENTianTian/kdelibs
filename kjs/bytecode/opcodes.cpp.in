/*
 *  Opcode data structure and selection routines for KJS/Frostbyte
 *  This file is part of the KDE libraries
 *  Copyright (C) 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include "opcodes.h"
#include "CompileState.h"
#include <cstdio>

namespace KJS {

const int Cost_NoConversion = -100000; // small enough so that adding actual costs doesn't
                                       // make it positive
const int Cost_Checked      = -2;

@generate

// Note: costOut will be Cost_NoConversion if no conversion is possible
static ConvOp computeCast(const OpValue* in, OpType outType, bool outImmediate, int& costOut)
{
    bool   inImmediate = in->immediate;
    OpType inType      = in->type;

    // Look up in the table..
    const ConvInfo* inf = getConversionInfo(inImmediate, inType, outType);

    if (inf->costCode == Cost_Checked) {
        ASSERT(inImmediate);
        ASSERT(outType == OpType_value);
        ASSERT(inType  == OpType_uint32 || inType == OpType_number);

        // Where a conversion is checked, we may not be able to get an
        // immediate<->immediate match, so we may have to generate
        // a special immediate<->register conversion.

        bool inlineOK = inType == OpType_uint32 ? JSImmediate::from(in->value.narrow.uint32Val) :
                                                  JSImmediate::from(in->value.wide.numberVal);

        if (outImmediate) {
            // immediate -> immediate..
            if (inlineOK)
                costOut = 0;
            else
                costOut = Cost_NoConversion;
            return inf->routine;
        } else {
            // immediate -> register;
            if (inlineOK) {
                costOut = Cost_NoConversion;
                // No point of doing this, can just do in place..
            } else {
                // cost about the same as register uint32-> number conversion
                costOut = getConversionInfo(false, OpType_uint32, OpType_value)->costCode;
                return inType == OpType_uint32 ? Conv_I_R_Uint32_Value :
                                                 Conv_I_R_Number_Value;
            }
        }
    }

    // Obviously, we can't make a register result into an an immediate value,
    // and we generally don't want to convert immediate values to registers,
    // since we can nearly always just do a perfect immediate conversion in-place.
    // But that fails only in case of checked conversions, which are handled above.
    if (outImmediate != inImmediate) {
        costOut = Cost_NoConversion;
        return Conv_NoConversion;
    }

    costOut = inf->costCode;
    return inf->routine;
}

static void emitConversion(CompileState* comp, CodeBlock& block, bool outImm,
                           ConvOp convType, OpValue* original, OpValue& out)
{
    if (outImm) {
        emitImmediateConversion(convType, original, out);
        return;
    }

    OpValue regNum;

    switch (convType) {
    case Conv_NoOp:
        out = *original;
        break;
    case Conv_RBool_Uint32:
        // This one's a no-op..
        out = *original;
        break;
    case Conv_RBool_Value: {
        comp->requestTemporary(OpType_value, out, regNum);
        CodeGen::emitOp(comp, block, Op_JsBoolean, &regNum, original);
    }
    break;

    case Conv_RValue_Bool: {
        comp->requestTemporary(OpType_bool, out, regNum);
        CodeGen::emitOp(comp, block, Op_ToBoolean, &regNum, original);
    }
    break;

    case Conv_RValue_Uint32: {
        comp->requestTemporary(OpType_uint32, out, regNum);
        CodeGen::emitOp(comp, block, Op_ToUInt32, &regNum, original);
    }
    break;

    case Conv_RUint32_Bool: {
        comp->requestTemporary(OpType_bool, out, regNum);
        CodeGen::emitOp(comp, block, Op_UInt32ToBool,  &regNum, original);
    }
    break;

    case Conv_RUint32_Value: {
        comp->requestTemporary(OpType_value, out, regNum);
        CodeGen::emitOp(comp, block, Op_JSNumberFromUInt32, &regNum, original);
    }
    break;

    case Conv_I_R_Uint32_Value: {
        comp->requestTemporary(OpType_value, out, regNum);
        CodeGen::emitOp(comp, block, Op_JSNumberFromUInt32, &regNum, original);
    }
    break;

    case Conv_I_R_Number_Value: {
        comp->requestTemporary(OpType_value, out, regNum);
        CodeGen::emitOp(comp, block, Op_JSNumber, &regNum, original);
    }
    break;

    default:
        printf("Unable to handle register conversion:%s\n", ConvOpVals[convType]);
        CRASH();
    };
}

// ### probably worth merging with patchOpArgument --- basically the same thing..
static void emitArg(unsigned char* basePtr, const Op* opDescr, int pos, const OpValue& val)
{
    ASSERT(opDescr->immediateParams[pos] == val.immediate);
    ASSERT(opDescr->paramTypes[pos] == val.type);

    unsigned char* argBase = basePtr + opDescr->paramOffsets[pos];
    if (val.immediate && opTypeIsAlign8[val.type]) {
        *reinterpret_cast<WideArg*>(argBase) = val.value.wide;
    } else {
        *reinterpret_cast<NarrowArg*>(argBase) = val.value.narrow;
    }
}

OpByteCode* CodeGen::emitOp(CompileState* comp, CodeBlock& block, OpName baseInstr,
                            OpValue* a0, OpValue* a1, OpValue* a2)
{
    const Op* const* cands = opSpecializations[baseInstr];

    const Op* cheapest = 0;
    int    cheapestCost = 0;
    ConvOp cheapestConvOps[3] = {Conv_NoConversion, Conv_NoConversion, Conv_NoConversion};

    int numArgs = 0;
    if (a0)
        numArgs = 1;
    if (a1)
        numArgs = 2;
    if (a2)
        numArgs = 3;

    // First, scan through, and determine the cheapest non-align variant.
    // We can't select whether to align or not, since we may have to emit
    // cast ops, which could change where we are.
    for (int c = 0; cands[c]; ++c) {
        const Op* cand = cands[c];
        ASSERT(cand->baseInstr == baseInstr);
        ASSERT(cand->numParams == numArgs);

        if (cand->padAlign)
            continue;

        int    cost0 = 0, cost1 = 0, cost2 = 0;
        ConvOp convOps[3];

        switch (numArgs) {
        case 3:
            convOps[2] = computeCast(a2, cand->paramTypes[2], cand->immediateParams[2], cost2);
            // Fallthrough
        case 2:
            convOps[1] = computeCast(a1, cand->paramTypes[1], cand->immediateParams[1], cost1);
            // Fallthrough
        case 1:
            convOps[0] = computeCast(a0, cand->paramTypes[0], cand->immediateParams[0], cost0);
            // Fallthrough
        case 0:
            break;
        }

        int totalCost = cand->cost + cost0 + cost1 + cost2;

        if (totalCost < 0) // Cost_NoConversion in the sum...
            continue;

        if (totalCost < cheapestCost || !cheapest) {
            cheapest        = cand;
            cheapestCost    = totalCost;
            cheapestConvOps[0] = convOps[0];
            cheapestConvOps[1] = convOps[1];
            cheapestConvOps[2] = convOps[2];
        }
    }

    if (!cheapest) {
        printf("Unable to find an acceptable conversion for:%s\n", OpNameVals[baseInstr]);
        if (a0)
            printf("\ta0:%s/imm:%d\n", OpTypeVals[a0->type], a0->immediate);
        if (a1)
            printf("\ta1:%s/imm:%d\n", OpTypeVals[a1->type], a1->immediate);
        if (a2)
            printf("\ta2:%s/imm:%d\n", OpTypeVals[a2->type], a2->immediate);
        CRASH(); // Should never happen!
    }

    OpValue c0, c1, c2; // Converted versions, if needed.

    switch (numArgs) {
    case 3:
        emitConversion(comp, block, cheapest->immediateParams[2], cheapestConvOps[2], a2, c2);
        // Fallthrough
    case 2:
        emitConversion(comp, block, cheapest->immediateParams[1], cheapestConvOps[1], a1, c1);
        // Fallthrough
    case 1:
        emitConversion(comp, block, cheapest->immediateParams[0], cheapestConvOps[0], a0, c0);
        // Fallthrough
    case 0:
        break;
    }

    // Now figure out if we need to do align.. We need it if the PC is 8-aligned, since
    // the instr will mess that up, and the instruction need it..
    if (cheapest->hasPadVariant && ((block.size() % 8) == 0)) {
        // The padded variant of the instruction always preceeds the unpadded one..
        cheapest = &opsForOpCodes[cheapest->opCode - 1];
    }

    // Phewww. Now we can actually write out stuff.
    size_t pos = block.size();
    block.resize(pos + cheapest->length);
    unsigned char* basePtr = block.data() + pos;

    // Write out the opcode..
    *reinterpret_cast<OpByteCode*>(basePtr) = cheapest->opCode;

    // ... and the args, as needed.
    switch (numArgs) {
    case 3:
        emitArg(basePtr, cheapest, 2, c2);
        // Fallthrough
    case 2:
        emitArg(basePtr, cheapest, 1, c1);
        // Fallthrough
    case 1:
        emitArg(basePtr, cheapest, 0, c0);
        // Fallthrough
    case 0:
        break;
    }

    return reinterpret_cast<OpByteCode*>(basePtr);
}

void CodeGen::patchOpArgument(OpByteCode* base, int pos, OpValue& newVal)
{
    const Op& variant = opsForOpCodes[*base];

    // We only permit patching immediate arguments for now..
    ASSERT(variant.immediateParams[pos] && newVal.immediate);

    char* argBase = reinterpret_cast<char*>(base) + variant.paramOffsets[pos];
    if (opTypeIsAlign8[variant.paramTypes[pos]])
        *reinterpret_cast<WideArg*>(argBase) = newVal.value.wide;
    else
        *reinterpret_cast<NarrowArg*>(argBase) = newVal.value.narrow;
}

static void dumpParam(CodeBlock& block, size_t offset, OpType type)
{
    switch (type) {
    case OpType_bool:
        if (reinterpret_cast<NarrowArg*>(block.data() + offset)->boolVal)
            std::printf("true");
        else
            std::printf("false");
        break;
    case OpType_uint32:
        std::printf("%d", reinterpret_cast<NarrowArg*>(block.data() + offset)->uint32Val);
        break;
    case OpType_value:
        // Immediate value -- should go through JSImmediate stuff..
        std::printf("<ival:%s>", reinterpret_cast<WideArg*>(block.data() + offset)->valueVal->toString(0).ascii());
        break;
    case OpType_ident:
        std::printf("%s", reinterpret_cast<WideArg*>(block.data() + offset)->identVal->ustring().ascii());
        break;
    case OpType_string:
        std::printf("\"%s\"", reinterpret_cast<WideArg*>(block.data() + offset)->stringVal->ascii());
        break;
    case OpType_number:
        std::printf("%f", reinterpret_cast<WideArg*>(block.data() + offset)->numberVal);
        break;
    case OpType_addr:
        std::printf("A%8x", reinterpret_cast<NarrowArg*>(block.data() + offset)->addrVal);
        break;
    case OpType_reg:
        std::printf("r%d", reinterpret_cast<NarrowArg*>(block.data() + offset)->regVal);
        break;
    default:
        std::printf("???:%s", OpTypeVals[type]);
    };
    std::printf(" ");
}

void CodeGen::disassembleBlock(CodeBlock& block)
{
    size_t pc = 0;
    while (pc < block.size()) {
        OpByteCode opCode = *reinterpret_cast<OpByteCode*>(block.data() + pc);
        const Op& opDescr = opsForOpCodes[opCode];

        std::printf("%08x %s ", pc, OpNameVals[opDescr.baseInstr]);
        for (int p = 0; p < opDescr.numParams; ++p) {
            dumpParam(block, pc + opDescr.paramOffsets[p],
                      opDescr.immediateParams[p] ? opDescr.paramTypes[p] : OpType_reg);
        }

        std::printf("\t\t// %s\n", OpByteCodeVals[opCode]);
        pc += opDescr.length;
    }
}

} //namespace KJS
// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;
