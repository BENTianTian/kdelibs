type bool: bool register immediate;
type uint32: uint32_t register immediate;
type value: JSValue* register align8; // ### I thought up of a usecase for immediate vals sometime last
                                      // night, but not sure what yet, so I am keeping them out..
type ident: Identifier* immediate align8;
type addr:  Addr        immediate;
type reg:   Register    immediate; // an output register

/**
Notes on the conversion rules from the spec:
The conversion operations in general do not form a commutative diagram ---
one can call toBoolean(toUInt32(foo)) and get something different
from toBoolean(foo). We don't worry about this, however, because when we
know the type enough to annotate it as uint32, etc., it's when the computation
would naturally produces a 32-bit int, so we would never marshal an object to it!
*/

// Conversions for immediate bool
conversion immediate imBool_imVal: bool => value  costs 0;
conversion immediate imBool_imInt: bool => uint32 costs 0;

// Register bool...
conversion register rBool_rVal: bool => value  costs 10; // Need to put in a call to jsBoolean.
conversion register rBool_rInt: bool => uint32 costs 0;  // Due to compatible representation

// Immediate JSValues should never be produced -- hmm, should I put in a failure production?

// Register JSValue..
conversion register rVal_rBool: value => bool costs 10;   // Need to call toBoolean. Extra op, but cheap.
conversion register rVal_rInt:  value => uint32 costs 30; // toUint32 can be more expensive, since it may get to
                                                          // toPrimitive, even!

// Immediate UInt32
conversion immediate checked imInt_imValue : uint32 => value costs 0; // if it succeeds, if it doesn't,
                                                                      // we can't emit the code anyway.
conversion immediate imInt_imBool : uint32 => bool costs 0;

// Register UInt32
conversion register rInt_rBool:  uint32 => bool  costs 0; // We permit bools to be any non-zero number when in register.
conversion register rInt_rValue: uint32 => value costs 20; // Cheap if it fits, if it doesn't, though, it calls jsNumber.

/**
 Control flow stuff
*/
operation Exit {
    impl() [[
        return Completion(Normal);
    ]]
}

operation Jump {
    impl(addr dest) [[
        pc = dest;
    ]]
}

operation IfJump {
    impl executeIfJump(bool condResult, addr dest) [[
        if (condResult)
            pc = dest;
    ]]

    tile (value, addr) as executeIfJump;
}

operation IfElseJump {
    impl executeIfElseJump(bool condResult, addr goTrue, addr goFalse) [[
        pc = condResult ? goTrue : goFalse;
    ]]

    tile (value, addr, addr) as executeIfElseJump;
}

// for, while, do ... while, etc., can all be easily expressed as above,
// ditto for continue / break

// ### switch is nasty. Probably needs some opaque pointer type.

operation PopCatch {
    impl() [[
        exec->popCatchHandler();
    ]]
}

operation PushCatch {
    impl(addr handler) [[
        exec->pushCatchHandler(handler);
    ]]
}

operation Throw {
    impl(value exception) [[
        exec->setException(exception);
        if (exec->hasCatchHandler())
            pc = exec->takeCatchHandler();
        else
            return Completion(Exception, exception);
    ]]
}

operation Return {
    impl(value retVal) [[
        return Completion(Normal, retVal);
    ]]
}

// Variable stuff... Locals access can just use register addressing,
// not specific get/put, but when we have to do symbolic lookup, we use these.

operation ScopeLookup {
    // Find which scope the variable is in, e.g. basically evaluates to a reference.
    impl scopeLookup(ident varName) [[
        //### TODO
    ]]
}

operation SymPut {
    impl symPut(value scope, ident varName, value val) [[
        ASSERT(scope->isObject());
        static_cast<JSObject*>(scope)->put(varName, val);
    ]]
}

operation SymGet {
    impl symGet(reg destReg, value scope, ident varName) [[
        ASSERT(scope->isObject());
        //### TODO
        // regs[destReg] = static_cast<JSObject*>(scope)->get(varName); or such
    ]]
}

// Specialization for global object...
operation GlobalSymPut {
    impl globalSymPut(ident varName, value val) [[
        //### TODO
    ]]
}

operation GlobalSymGet {
    impl globalGet(reg dstReg, ident varName) [[
        //### TODO
    ]]
}

// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;
