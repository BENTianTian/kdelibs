/*
 *  This describe the various bytecode operations for KJS/Frostbyte, and gives their implementations
 *
 *  This file is part of the KDE libraries
 *  Copyright (C) 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// JS types.
type bool: bool register immediate;

// We do not have to have a separate int32 type, since the uint32 and int32
// conversions behave sanely, and hence the impls can just fiddle as appropriate
type uint32: uint32_t register immediate;

// We could provide immediate JSValue's, but they'd only matter for null/undefined. Easier to
// just use registers and ops, since they're likely sufficiently cold, and won't blow up
// the operand tables so much
type value:  JSValue* register align8;

// Note: number can't possibly be register, it won't fit on 32-bit!
// ### we might want separate areas, but then we can't store a non-immediate value into a real
// local anyway.
type number: double immediate align8;

// Program types; these all represent stuff in source code and not actual program values
// Hence, no conversions for them.
type ident:  Identifier* immediate align8;
type addr:  Addr        immediate;
type reg:   Register    immediate; // an output register

// We have to be careful with this type --- it only represents
// string literals in the program, as we have no nice way of memory managing others..
// ### we may want to use a register jsString type instead, in particular to
// infer the proper overload of +, when appropriate
type string: UString* immediate align8;

/**
Notes on the conversion rules from the spec:
The conversion operations in general do not form a commutative diagram ---
one can call toBoolean(toUInt32(foo)) and get something different
from toBoolean(foo). We don't worry about this, however, because when we
know the type enough to annotate it as uint32, etc., it's when the computation
would naturally produces a 32-bit int, so we would never marshal an object to it!

We also never chain multiple conversions ourselves.
*/

/*
 Conversions from bool
*/
conversion bool => uint32 {
    impl [[
        return in ? 1 : 0;
    ]]

    tile costs 0; //cost in tile..
    register  rBool_Int costs 0; // we always store bool as 0/1, so this is free.
}

conversion bool => value {
    impl [[
        return jsBoolean(in);
    ]]

    tile costs 0;
    register rBool_Value costs 10; // Separate jsBoolean instruction
}

conversion bool => number {
    impl [[
        return in ? 1.0 : 0.0;
    ]]

    tile costs 0;
}

/*
 Conversions from values
*/
conversion value => bool {
    impl [[
        return in->toBoolean(exec);
    ]]

    tile costs 5; // it is a virtual call
    register rValue_Bool costs 15; // ToBoolean instr, includes a virtual call..
}

conversion value => uint32 {
    impl mayThrow [[
        return in->toUInt32(exec);
    ]]

    tile costs 40; // toUInt32 used to number --- expensive
    register rValue_UInt32 costs 50; // above, plus a separate instr
}

conversion value => number {
    impl mayThrow [[
        return in->toNumber(exec);
    ]]

    tile costs 37;
}

/*
 Conversions from uint32
*/
conversion uint32 => bool {
    impl [[
        return in ? true : false; // Expect stupid MSVC 0/1 warning
    ]]

    tile costs 0;
    register rUInt32_Bool costs 10;
}

conversion uint32 => value {
    impl checked mayThrow /* due to OOM */ [[
        return jsNumber(in);
    ]]

    tile costs 15;
    register rUInt32_Value costs 25;
}

conversion uint32 => number {
    impl [[
        return in;
    ]]

    tile costs 3;
    register rUInt32_Number costs 13;
}

/*
 Conversions from number
*/
conversion number => bool {
    impl [[
        // ### FIXME
        abort();
    ]]

    tile costs 15;
}

conversion number => value {
    impl checked mayThrow /* due to OOM */ [[
        return jsNumber(in);
    ]]

    tile costs 15;
}

conversion number => uint32 {
    impl [[
        return JSValue::toUInt32(in);
    ]]

    tile costs 10;
}


/**
 These are needed for basic types, conversions, etc.
*/
operation Null {
    impl(reg outReg) [[
        localStore[outReg].valueVal = jsNull();
    ]]
}

operation Undefined {
    impl(reg outReg) [[
        localStore[outReg].valueVal = jsUndefined();
    ]]
}

operation OwnedString {
    impl(reg outReg, string in) [[
        localStore[outReg].valueVal = jsOwnedString(in);
    ]]
}

operation JsBoolean {
    impl(reg outReg, bool in) [[
        localStore[outReg].valueVal = jsBoolean(in);
    ]]
}

operation ToBoolean {
    impl(reg outReg, value in) [[
        localStore[outReg].boolVal = in->toBoolean(exec);
    ]]
}

operation ToUInt32 {
    impl(reg outReg, value in) [[
        localStore[outReg].uint32Val = in->toUInt32(exec);
    ]]
}

operation UInt32ToBool {
    impl(reg outReg, uint32 in) [[
        localStore[outReg].boolVal = in ? true : false;
    ]]
}

operation JSNumber {
    impl(reg outReg, uint32 in) [[
        localStore[outReg].valueVal = jsNumber(in);
    ]]
}

/**
 Control flow stuff
*/
operation Exit {
    impl() [[
        return Completion(Normal);
    ]]
}

operation Jump {
    impl(addr dest) [[
        pc = dest;
    ]]
}

operation IfJump {
    impl executeIfJump(bool condResult, addr dest) [[
        if (condResult)
            pc = dest;
    ]]

    tile (value, addr) as executeIfJump;
}

operation IfElseJump {
    impl executeIfElseJump(bool condResult, addr goTrue, addr goFalse) [[
        pc = condResult ? goTrue : goFalse;
    ]]

    tile (value, addr, addr) as executeIfElseJump;
}

// for, while, do ... while, etc., can all be easily expressed as above,
// ditto for continue / break

// ### switch is nasty. Probably needs some opaque pointer type.

operation PopCatch {
    impl() [[
        exec->popCatchHandler();
    ]]
}

operation PushCatch {
    impl(addr handler) [[
        exec->pushCatchHandler(handler);
    ]]
}

operation Throw {
    impl(value exception) [[
        exec->setException(exception);
        if (exec->hasCatchHandler())
            pc = exec->takeCatchHandler();
        else
            return Completion(Exception, exception);
    ]]
}

operation Return {
    impl(value retVal) [[
        return Completion(Normal, retVal);
    ]]
}

// Variable stuff... Locals access can just use register addressing,
// not specific get/put, but when we have to do symbolic lookup, we use these.

operation ScopeLookup {
    // Find which scope the variable is in, e.g. basically evaluates to a reference.
    impl scopeLookup(ident varName) [[
        //### TODO
    ]]
}

operation SymPut {
    impl symPut(value scope, ident varName, value val) [[
        ASSERT(scope->isObject());
        static_cast<JSObject*>(scope)->put(varName, val);
    ]]
}

operation SymGet {
    impl symGet(reg destReg, value scope, ident varName) [[
        ASSERT(scope->isObject());
        //### TODO
        // regs[destReg] = static_cast<JSObject*>(scope)->get(varName); or such
    ]]
}

// Specialization for global object...
operation GlobalSymPut {
    impl globalSymPut(ident varName, value val) [[
        //### TODO
    ]]
}

operation GlobalSymGet {
    impl globalGet(reg dstReg, ident varName) [[
        //### TODO
    ]]
}

/**
 Bitops stuff
*/
operation And {
    //### FIXME: this actually distinguishes uin32/int32 --- double-check!
    impl andOp(reg dstReg, uint32 a0, uint32 a1) [[
        localStore[dstReg].uint32Val = a0 & a1;
    ]]

    tile (reg, value, value) as andOp;
    tile (reg, value, uint32) as andOp;
    tile (reg, uint32, value) as andOp;
}

// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;
