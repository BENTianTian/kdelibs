/*
 *  This describe the various bytecode operations for KJS/Frostbyte, and gives their implementations
 *
 *  This file is part of the KDE libraries
 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
 *  Copyright (C) 2003, 2004, 2005, 2006, 2007 Apple Inc. All rights reserved.
 *  Copyright (C) 2007, 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// JS types.
type bool: bool register immediate;

// We have to be careful about uint32/int32, as while number -> them behaves
// transparently, the results may be converted back to a number, which may show
// a sign
type int32: int32_t register immediate;

// We provide immediate JSValue's, for the following:
// 1) Small numeric constants
// 2) undefined and null.
// This relies on immediate value JSValue conversion rountines not touching exec!
type value:  JSValue* register immediate align8;

type number: double register immediate align8;

// Program types; these all represent stuff in source code and not actual program values
// Hence, no conversions for them.
type ident:  Identifier* immediate align8;
type addr:  Addr        immediate;
type reg:   Register    immediate; // an output register

// We have to be careful with this type --- it only represents
// string literals in the program, as we have no nice way of memory managing others..
// ### we may want to use a register jsString type instead, in particular to
// infer the proper overload of +, when appropriate
type string: UString* immediate align8;

// AST nodes passed to helpers... They may cast it further..
type node: Node* immediate align8;
type cstr: const char* immediate align8;

// Just for the return type...
type void: void immediate;

/**
Notes on the conversion rules from the spec:
The conversion operations in general do not form a commutative diagram ---
one can call toBoolean(toUInt32(foo)) and get something different
from toBoolean(foo). We don't worry about this, however, because when we
know the type enough to annotate it as uint32, etc., it's when the computation
would naturally produces a 32-bit int, so we would never marshal an object to it!

We also never chain multiple conversions ourselves.
*/

/*
 Conversions from bool
*/
conversion bool => int32 {
    impl [[
        return in ? 1 : 0;
    ]]

    tile costs 0; //cost in tile..
    register  RBool_Int32 costs 0; // we always store bool as 0/1, so this is free.
}

conversion bool => value {
    impl [[
        return jsBoolean(in);
    ]]

    tile costs 0;
    register RBool_Value costs 10; // Separate jsBoolean instruction
}

conversion bool => number {
    impl [[
        return in ? 1.0 : 0.0;
    ]]

    tile costs 0;
    register RBool_Number costs 10;
}

/*
 Conversions from values
*/
conversion value => bool {
    impl [[
        return in->toBoolean(exec);
    ]]

    tile costs 5; // it is a virtual call
    register RValue_Bool costs 15; // ToBoolean instr, includes a virtual call..
}

conversion value => int32 {
    impl mayThrow [[
        return in->toInt32(exec);
    ]]

    tile costs 40; // toInt32 uses toNumber --- expensive
    register RValue_Int32 costs 50; // above, plus a separate instr
}

conversion value => number {
    impl mayThrow [[
        return in->toNumber(exec);
    ]]

    tile costs 37;
    register RValue_Number costs 49;
}

/*
 Conversions from int32
*/
conversion int32 => bool {
    impl [[
        return in ? true : false; // Expect stupid MSVC 0/1 warning
    ]]

    tile costs 0;
    register RInt32_Bool costs 10;
}

conversion int32 => value {
    impl checked mayThrow /* due to OOM */ [[
        return jsNumber(in);
    ]]

    tile costs 15;
    register RInt32_Value costs 25;
}

conversion int32 => number {
    impl [[
        return in;
    ]]

    tile costs 3;
    register RInt32_Number costs 10;
}

/*
 Conversions from number
*/
conversion number => bool {
    impl [[
        // ### FIXME
        abort();
    ]]

    tile costs 15;
    register RNumber_Bool costs 25;
}

conversion number => value {
    impl checked mayThrow /* due to OOM */ [[
        return jsNumber(in);
    ]]

    tile costs 15;
    register RNumber_Value costs 35;
}

conversion number => int32 {
    impl [[
        return JSValue::toInt32(in);
    ]]

    tile costs 10;
    register RNumber_Int32 costs 20;
}

/**
 Debug only..
 */
operation PrintInfo {
    impl void(value in) [[
        printInfo(exec, "", in);
    ]]
}

/**
 These are needed for basic types, conversions, etc.
*/

operation OwnedString {
    impl value ownedString(string in) [[
        $$ = jsOwnedString(*in);
    ]]
}

operation JsBoolean {
    impl value jsBoolean(bool in) [[
        $$ = jsBoolean(in);
    ]]
}

operation ToBoolean {
    impl bool toBoolean(value in) [[
        $$ = in->toBoolean(exec);
    ]]
}

operation ToInt32 {
    impl int32 toInt32(value in) [[
        $$ = in->toInt32(exec);
    ]]
}

operation ToNumber {
    impl number(value in) [[
        $$ = in->toNumber(exec);
    ]]
}

operation Int32ToBool {
    impl bool int32ToBool(int32 in) [[
        $$ = in ? true : false;
    ]]
}

operation Int32ToNumber {
    impl number (int32 in) [[
        $$ = in;
    ]]
}

operation NumberToBool {
    impl bool(number in) [[
        //### TODO:
        abort();
    ]]
}

operation NumberToInt32 {
    impl int32(number in) [[
        $$ = JSValue::toInt32(in);
    ]]
}

operation JSNumberFromInt32 {
    impl value jsNum(int32 in) [[
        $$ = jsNumber(in);
    ]]
}

operation JSNumber {
    impl value jsNum(number in) [[
        $$ = jsNumber(in);
    ]]
}

operation This {
    impl value getThis() [[
        $$ = exec->thisValue();
    ]]
}



/**
 Control flow stuff
*/
operation Exit {
    impl void exit() [[
        return Completion(Normal);
    ]]
}

operation Jump {
    impl void jump(addr dest) [[
        pc = dest;
    ]]
}

operation IfJump {
    impl void executeIfJump(bool condResult, addr dest) [[
        if (condResult)
            pc = dest;
    ]]

    tile (value, addr) as executeIfJump;
}

operation IfNotJump {
    impl void executeIfNotJump(bool condResult, addr dest) [[
        if (!condResult)
            pc = dest;
    ]]

    tile (value, addr) as executeIfNotJump;
}

// for, while, do ... while, etc., can all be easily expressed as above,
// ditto for continue / break

// ### switch is nasty. Probably needs some opaque pointer type.

// These update the scope chain, and sets the special unwind exception handler, which is used to
// restore the chain if an exception happens
operation PushScope {
    impl void pushScope(value in) [[
        JSObject* obj = in->toObject(exec);
        if (exec->hadException())
            continue; // will jump to handler.

        exec->pushScope(obj);
        exec->pushExceptionHandler(ExecState::PopScope);
    ]]
}

operation PopScope {
    impl void () [[
        exec->popScope();
        exec->popExceptionHandler();
    ]]
}

operation PopCatch {
    impl void popCatch() [[
        exec->popExceptionHandler();
    ]]
}

operation PushCatch {
    impl void pushCatch(addr handler) [[
        exec->pushExceptionHandler(ExecState::JumpToCatch, handler);
    ]]
}

operation Throw {
    impl void throw(value exception) [[
#if 0
        exec->setException(exception);
        if (exec->hasCatchHandler())
            pc = exec->takeCatchHandler();
        else
            return Completion(Throw, exception);
#endif
    ]]
}

operation PropagateException {
    impl void() [[
        return Completion(Throw, exec->exception());
    ]]
}

operation Return {
    impl void return (value retVal) [[
        return Completion(Normal, retVal);
    ]]
}

operation RaiseError {
    impl void (node node, int32 errorType, cstr msg) [[
        // ### TODO!
        ASSERT(0);
        //return node->createErrorCompletion(exec, ErrorType(errorType), msg);
    ]]
}

// Variable stuff... Locals access can just use register addressing,
// not specific get/put, but when we have to do symbolic lookup, we use these.
operation GetVariableObject {
    impl value getVariableObject() [[
        $$ = exec->variableObject();
    ]]
}

operation GetGlobalObject {
    impl value() [[
        $$ = exec->dynamicInterpreter()->globalObject();
    ]]
}

operation ScopeLookup {
    // Find which scope the variable is in, e.g. basically evaluates to a reference.
    impl value scopeLookup(ident varName, bool errorOnFailure) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        JSObject *scopeObj;
        PropertySlot slot;
        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, *varName, slot))
                break;
            ++iter;
        } while (iter != end);

        if (errorOnFailure && iter == end) {
            // ### TODO: issue error
        }

        $$ = scopeObj;
    ]]
}

operation NonLocalScopeLookup {
    // As above, but may skip one step
    impl value scopeLookup(ident varName, bool errorOnFailure) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        JSObject *scopeObj = *iter;
        if (!scopeObj->isLocalInjected()) {
            // Unless eval introduced new variables dynamically,
            // we know this isn't in the top scope
            ++iter;
        }

        PropertySlot slot;
        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, *varName, slot))
                break;
            ++iter;
        } while (iter != end);

        if (errorOnFailure && iter == end) {
            // ### TODO: issue error
        }
        $$ = scopeObj;
    ]]
}


// Looks up a given variable in the scope chain, returns its value
operation VarGet {
    impl value localVarGet(ident varName) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        PropertySlot slot;
        JSObject *scopeObj;
        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, *varName, slot)) {
                $$ = slot.getValue(exec, scopeObj, *varName);
                break;
            }

            ++iter;
        } while (iter != end);

        if (iter == end) {
            // #### TODO throwUndefinedVariableError(exec, ident); //### FIXME
        }
    ]]
}

// Like above, but skips the first step, if possible.
operation NonLocalVarGet {
    impl value nonLocalVarGet(ident varName) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        PropertySlot slot;
        JSObject *scopeObj = *iter;

        if (!scopeObj->isLocalInjected()) {
            // Unless eval introduced new variables dynamically,
            // we know this isn't in the top scope
            ++iter;
        }

        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, *varName, slot)) {
                $$ = slot.getValue(exec, scopeObj, *varName);
                break;
            }

            ++iter;
        } while (iter != end);

        if (iter == end) {
            // ### FIXME throwUndefinedVariableError(exec, ident);
        }
    ]]
}

operation RegPutValue {
    impl void regPut(reg destReg, value val) [[
        localStore[destReg].val.valueVal = val;
    ]]
}

operation RegPutNumber {
    impl void (reg destReg, number val) [[
        localStore[destReg].val.numberVal = val;
    ]]
}

operation RegPutBool {
    impl void (reg destReg, bool val) [[
        localStore[destReg].val.boolVal = val;
    ]]
}

operation RegPutInt32 {
    impl void (reg destReg, int32 val) [[
        localStore[destReg].val.int32Val = val;
    ]]
}

// Generic put..
operation SymPut {
    impl void symPut(value base, ident varName, value val) [[
        JSObject* baseObj = base->toObject(exec);
        if (!exec->hadException())
            baseObj->put(exec, *varName, val);
    ]]
}

// Put for a scope -- known to be an object!
operation SymPutKnownObject {
    impl void symPutKnownObject(value scope, ident varName, value val) [[
        ASSERT(scope->isObject());
        static_cast<JSObject*>(scope)->put(exec, *varName, val);
    ]]

    tile (value, ident, number) as symPutKnownObject;
}

// Generic get..
operation SymGet {
    impl value symGet(value base, ident prop) [[
        JSObject* baseObj = base->toObject(exec);
        // toObject may fail and return an exception object, but get from it is harmless

        $$ = baseObj->get(exec, *prop);
    ]]
}

operation IndexGet {
    impl value indexGet(value base, int32 prop) [[
        JSObject* baseObj = base->toObject(exec);
        // toObject may fail and return an exception object, but get from it is harmless

        $$ = baseObj->get(exec, (uint32_t)prop);
    ]]
}

operation BracketGet {
    impl value (value v1, value v2) [[
        uint32_t i;
        JSObject *o = v1->toObject(exec);
        // toObject may fail and return an exception object, but get from it is harmless

        if (v2->getUInt32(i))
            $$ = o->get(exec, i);
        else
            $$ = o->get(exec, Identifier(v2->toString(exec)));
    ]]
}

operation IndexPut {
    impl void indexPut(value base, int32 prop, value val) [[
        JSObject* baseObj = base->toObject(exec);
        if (!exec->hadException())
            baseObj->put(exec, (uint32_t)prop, val);
    ]]
}

operation BracketPut {
    impl void (value v1, value v2, value v3) [[
        uint32_t i;
        JSObject *o = v1->toObject(exec);
        if (exec->hadException())
            break;

        if (v2->getUInt32(i))
            o->put(exec, i, v3);
        else
            o->put(exec, Identifier(v2->toString(exec)), v3);
    ]]
}

// Get for a scope -- known to be an object!
operation SymGetKnownObject {
    impl value symScopeGet(value base, ident varName) [[
        ASSERT(base->isObject());
        $$ = static_cast<JSObject*>(base)->get(exec, *varName);
    ]]
}

operation SymGetVarObject {
    impl value(ident varName) [[
        $$ = exec->variableObject()->get(exec, *varName);
    ]]
}

operation NewObject {
    impl value() [[
        $$ = new JSObject(exec->lexicalInterpreter()->builtinObjectPrototype());
    ]]
}

operation DefineGetter {
    impl void(value base, ident name, value getter) [[
        ASSERT(base->isObject());
        ASSERT(getter->isObject());
        static_cast<JSObject*>(base)->defineGetter(exec, *name, static_cast<JSObject*>(getter));
    ]]
}

operation DefineSetter {
    impl void(value base, ident name, value setter) [[
        ASSERT(base->isObject());
        ASSERT(setter->isObject());
        static_cast<JSObject*>(base)->defineSetter(exec, *name, static_cast<JSObject*>(setter));
    ]]
}


/**
 Numeric ops
 */
operation Add1 {
    impl number add1(number old) [[
        $$ = old + 1.0;
    ]]

    tile (value) as add1;
}

operation Sub1 {
    impl number sub1(number old) [[
        $$ = old - 1.0;
    ]]
}

operation Neg {
    impl number neg(number old) [[
        $$ = -old;
    ]]
}

operation Mult {
    impl number(number v1, number v2) [[
        $$ = v1 * v2;
    ]]
}

operation Div {
    impl number(number v1, number v2) [[
        $$ = v1 / v2;
    ]]
}

operation Mod {
    impl number(number v1, number v2) [[
        $$ = fmod(v1, v2);
    ]]
}

operation Sub {
    impl number(number v1, number v2) [[
        $$ = v1 - v2;
    ]]
}

operation Add {
    impl value(value v1, value v2) [[
        // exception for the Date exception in defaultValue()
        JSValue *p1 = v1->toPrimitive(exec, UnspecifiedType);
        JSValue *p2 = v2->toPrimitive(exec, UnspecifiedType);

        if (p1->isString() || p2->isString()) {
            UString value = p1->toString(exec) + p2->toString(exec);
            if (value.isNull()) {
                JSObject *error = Error::create(exec, GeneralError, "Out of memory");
                exec->setException(error);
            } else {
                $$ = jsString(value);
            }
        } else {
            $$ = jsNumber(p1->toNumber(exec) + p2->toNumber(exec));
        }
    ]]
}


operation LShift {
    impl int32(int32 v1, int32 v2) [[
        $$ = (v1 << ((uint32_t)v2 & 0x1f));
    ]]
}

operation RShift {
    impl int32(int32 v1, int32 v2) [[
        $$ = (v1 >> ((uint32_t)v2 & 0x1f));
    ]]
}

operation Less {
    // ### ??? TODO: conversion-less overloads here, when core supports them ???

    impl bool(value v1, value v2) [[
        // operator <
        // -1: NaN, undefined => false
        //  0: v1 >= v2       => false
        //  1: v1 <  v2       => true;
        $$ = (relation(exec, v1, v2) == 1);
    ]]
}

operation GreaterEq {
    impl bool(value v1, value v2) [[
        // operator >=
        // -1: NaN, undefined => false
        //  0: v1 >= v2       => true
        //  1: v1 <  v2       => false;
        $$ = (relation(exec, v1, v2) == 0);
    ]]
}

operation Greater {
    impl bool(value v1, value v2) [[
        // operator >
        // -1: NaN, undefined => false
        //  0: v2 >= v1       => false
        //  1: v2 <  v1       => true
        $$ = (relation(exec, v2, v1) == 1);
    ]]
}

operation LessEq {
    impl bool(value v1, value v2) [[
        // operator <=
        // -1: NaN, undefined => false
        //  0: v2 >= v1       => true
        //  1: v2 <  v1       => false
        $$ = (relation(exec, v2, v1) == 0);
    ]]
}

operation EqEq {
    impl bool(value v1, value v2) [[
        // operator ==
        $$ = equal(exec,v1, v2);
    ]]
}

operation NotEq {
    impl bool(value v1, value v2) [[
        // operator !=
        $$ = !equal(exec,v1, v2);
    ]]
}


operation StrEq {
    impl bool(value v1, value v2) [[
        // operator ===
        $$ = strictEqual(exec,v1, v2);
    ]]
}

operation StrNEq {
    impl bool(value v1, value v2) [[
        // operator !==
        $$ = strictEqual(exec,v1, v2);
    ]]
}


/**
 Bitops stuff
*/
operation BitNot {
    impl int32 bitNot(int32 old) [[
        $$ = ~old;
    ]]
}

operation BitAnd {
    impl int32 andOp(int32 a0, int32 a1) [[
        $$ = a0 & a1;
    ]]

    tile (value, value) as andOp;
    tile (value, int32) as andOp;
    tile (int32, value) as andOp;
}

operation BitXOr {
    impl int32 (int32 a0, int32 a1) [[
        $$ = a0 ^ a1;
    ]]
}

operation BitOr {
    impl int32 (int32 a0, int32 a1) [[
        $$ = a0 ^ a1;
    ]]
}


/**
 Logical ops... All one of them!
*/
operation LogicalNot {
    impl bool logicalNot(bool old) [[
        $$ = !old;
    ]]
}

/**
 Function call stuff, for first prototype.
*/
operation ClearArgs {
    impl void() [[
        workList.clear();
    ]]
}

operation AddArg {
    impl void(value val) [[
        workList.append(val);
    ]]
}

operation Add2Arg {
    impl void(value a1, value a2) [[
        workList.append(a1);
        workList.append(a2);
    ]]
}

operation Add3Arg {
    impl void(value a1, value a2, value a3) [[
        workList.append(a1);
        workList.append(a2);
        workList.append(a3);
    ]]
}


operation FunctionCall {
    impl value(value v, value thisVal) [[
        if (!v->isObject()) {
            //return throwError(exec, TypeError, notAnObjectMessage(), v, expr.get());
            break;
            // ### TODO
        }

        JSObject *func = static_cast<JSObject*>(v);

        if (!func->implementsCall()) {
            //return throwError(exec, TypeError, notCallableMessage(), v, expr.get());
            break;
            // ### TODO
        }

        // ### TODO: optimize away toObject in local cases?
        $$ = static_cast<JSObject*>(func)->call(exec, thisVal->toObject(exec), workList);
    ]]
}

operation CtorCall {
    impl value(value v) [[
        if (!v->isObject()) {
            //return throwError(exec, TypeError, "Value %s (result of expression %s) is not an object. Cannot be used with new.", v, expr.get());
            // ### TODO
            break;
        }

        JSObject *constr = static_cast<JSObject*>(v);
        if (!constr->implementsConstruct()) {
            // ### TODO
            // return throwError(exec, TypeError, "Value %s (result of expression %s) is not a constructor. Cannot be used with new.", v, expr.get());
            break;
        }

        $$ = constr->construct(exec, workList);
    ]]
}


// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;
