// ### I should put in 8-align annotations. This will also permit 'double'
type void: void;
type bool: bool register immediate;
type uint32: uint32_t register immediate;
type value: JSValue* register align8; // ### I thought up of a usecase for immediate vals sometime last
                                      // night, but not sure what yet, so I am keeping them out..
type ident: Identifier* immediate align8;
type addr:  Addr        immediate;
type reg:   Register    immediate; // an output register

/**
Notes on the conversion rules from the spec:
The conversion operations in general do not form a commutative diagram ---
one can call toBoolean(toUInt32(foo)) and get something different
from toBoolean(foo). We don't worry about this, however, because when we
know the type enough to annotate it as uint32, etc., it's when the computation
would naturally produces a 32-bit int, so we would never marshal an object to it!
*/

// Conversions for immediate bool
conversion immediate imBool_imVal: bool => value  costs 0;
conversion immediate imBool_imInt: bool => uint32 costs 0;

// Register bool...
conversion register rBool_rVal: bool => value  costs 10; // Need to put in a call to jsBoolean.
conversion register rBool_rInt: bool => uint32 costs 0;  // Due to compatible representation

// Immediate JSValues should never be produced -- hmm, should I put in a failure production?

// Register JSValue..
conversion register rVal_rBool: value => bool costs 10;   // Need to call toBoolean. Extra op, but cheap.
conversion register rVal_rInt:  value => uint32 costs 30; // toUint32 can be more expensive, since it may get to
                                                          // toPrimitive, even!

// Immediate UInt32
conversion immediate checked imInt_imValue : uint32 => value costs 0; // if it succeeds, if it doesn't,
                                                                      // we can't emit the code anyway.
conversion immediate imInt_imBool : uint32 => bool costs 0;

// Register UInt32
conversion register rInt_rBool:  uint32 => bool  costs 0; // We permit bools to be any non-zero number when in register.
conversion register rInt_rValue: uint32 => value costs 20; // Cheap if it fits, if it doesn't, though, it calls jsNumber.



/**
 Control flow stuff
*/

operation Jump {
    impl executeJump : addr;
}

operation IfJump {
    impl executeIfJump : bool * addr;
    tile value * addr as executeIfJump;
}

operation IfElseJump {
    impl executeIfElseJump : bool * addr * addr;
    tile value * addr * addr as executeIfElseJump;
}

// for, while, do ... while, etc., can all be easily expressed as above,
// ditto for continue / break

// ### switch is nasty. Probably needs some opaque pointer type.

operation PopCatch {
    impl popCatch: void;
}

operation PushCatch {
    impl pushCache: addr;
}

operation Throw {
    impl executeThrow: value;
}

// Variable stuff... Locals access can just use register addressing,
// not specific get/put, but when we have to do symbolic lookup, we use these.

operation ScopeLookup {
    // Find which scope the variable is in, e.g. basically evaluates to a reference.
    impl scopeLookup: ident;
}

operation SymPut {
    impl symPut: value * ident * value; // scope.ident = val
}

operation SymGet {
    impl symGet: reg * value * ident; // reg = val.ident
}

// Specialization for global object...
operation GlobalSymPut {
    impl globalPut: ident * value;
}

operation GlobalSymGet {
    impl globalGet: reg * value;
}

/**
 An alternative approach for this may be to provide a globalScope pseudo-type, which would something like this:

 type globalScope: bool immediate; // any small type will do..
 operation SymPut {
    impl symPut: value * ident * value;
    tile globalScope * ident * value as symPut;
 }

 conversion immediate getGlobalScope: globalScope => value costs 1000; // so we don't pick the overload over perfect match

 And then have a:
 JSValue* convertGetGlobalScope(bool) {
    return exec->dynamicGlobalObject();
 }

 or whatever it'll be called.



*/
