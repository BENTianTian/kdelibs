/*
 *  This describe the various bytecode operations for KJS/Frostbyte, and gives their implementations
 *
 *  This file is part of the KDE libraries
 *  Copyright (C) 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

// JS types.
type bool: bool register immediate;

// We do not have to have a separate int32 type, since the uint32 and int32
// conversions behave sanely, and hence the impls can just fiddle as appropriate
type uint32: uint32_t register immediate;

// We provide immediate JSValue's, for the following:
// 1) Small numeric constants
// 2) undefined and null.
// This relies on immediate value JSValue conversion rountines not touching exec!
type value:  JSValue* register immediate align8;

type number: double register immediate align8;

// Program types; these all represent stuff in source code and not actual program values
// Hence, no conversions for them.
type ident:  Identifier* immediate align8;
type addr:  Addr        immediate;
type reg:   Register    immediate; // an output register

// We have to be careful with this type --- it only represents
// string literals in the program, as we have no nice way of memory managing others..
// ### we may want to use a register jsString type instead, in particular to
// infer the proper overload of +, when appropriate
type string: UString* immediate align8;

// AST nodes passed to helpers... They may cast it further..
type node: Node* immediate align8;
type cstr: const char* immediate align8;

// Just for the return type...
type void: void immediate;

/**
Notes on the conversion rules from the spec:
The conversion operations in general do not form a commutative diagram ---
one can call toBoolean(toUInt32(foo)) and get something different
from toBoolean(foo). We don't worry about this, however, because when we
know the type enough to annotate it as uint32, etc., it's when the computation
would naturally produces a 32-bit int, so we would never marshal an object to it!

We also never chain multiple conversions ourselves.
*/

/*
 Conversions from bool
*/
conversion bool => uint32 {
    impl [[
        return in ? 1 : 0;
    ]]

    tile costs 0; //cost in tile..
    register  RBool_Uint32 costs 0; // we always store bool as 0/1, so this is free.
}

conversion bool => value {
    impl [[
        return jsBoolean(in);
    ]]

    tile costs 0;
    register RBool_Value costs 10; // Separate jsBoolean instruction
}

conversion bool => number {
    impl [[
        return in ? 1.0 : 0.0;
    ]]

    tile costs 0;
    register RBool_Number costs 10;
}

/*
 Conversions from values
*/
conversion value => bool {
    impl [[
        return in->toBoolean(exec);
    ]]

    tile costs 5; // it is a virtual call
    register RValue_Bool costs 15; // ToBoolean instr, includes a virtual call..
}

conversion value => uint32 {
    impl mayThrow [[
        return in->toUInt32(exec);
    ]]

    tile costs 40; // toUInt32 used to number --- expensive
    register RValue_Uint32 costs 50; // above, plus a separate instr
}

conversion value => number {
    impl mayThrow [[
        return in->toNumber(exec);
    ]]

    tile costs 37;
    register RValue_Number costs 49;
}

/*
 Conversions from uint32
*/
conversion uint32 => bool {
    impl [[
        return in ? true : false; // Expect stupid MSVC 0/1 warning
    ]]

    tile costs 0;
    register RUint32_Bool costs 10;
}

conversion uint32 => value {
    impl checked mayThrow /* due to OOM */ [[
        return jsNumber(in);
    ]]

    tile costs 15;
    register RUint32_Value costs 25;
}

conversion uint32 => number {
    impl [[
        return in;
    ]]

    tile costs 3;
    register RUint32_Number costs 10;
}

/*
 Conversions from number
*/
conversion number => bool {
    impl [[
        // ### FIXME
        abort();
    ]]

    tile costs 15;
    register RNumber_Bool costs 25;
}

conversion number => value {
    impl checked mayThrow /* due to OOM */ [[
        return jsNumber(in);
    ]]

    tile costs 15;
    register RNumber_Value costs 35;
}

conversion number => uint32 {
    impl [[
        return JSValue::toUInt32(in);
    ]]

    tile costs 10;
    register RNumber_Uint32 costs 20;
}


/**
 These are needed for basic types, conversions, etc.
*/

operation OwnedString {
    impl value ownedString(string in) [[
        $$ = jsOwnedString(in);
    ]]
}

operation JsBoolean {
    impl value jsBoolean(bool in) [[
        $$ = jsBoolean(in);
    ]]
}

operation ToBoolean {
    impl bool toBoolean(value in) [[
        $$ = in->toBoolean(exec);
    ]]
}

operation ToUInt32 {
    impl uint32 toUInt32(value in) [[
        $$ = in->toUInt32(exec);
    ]]
}

operation ToNumber {
    impl number(value in) [[
        $$ = in->toNumber(exec);
    ]]
}

operation UInt32ToBool {
    impl bool uint32ToBool(uint32 in) [[
        $$ = in ? true : false;
    ]]
}

operation JSNumberFromUInt32 {
    impl value jsNum(uint32 in) [[
        $$ = jsNumber(in);
    ]]
}

operation JSNumber {
    impl value jsNum(number in) [[
        $$ = jsNumber(in);
    ]]
}

operation This {
    impl value getThis() [[
        $$ = exec->thisValue();
    ]]
}



/**
 Control flow stuff
*/
operation Exit {
    impl void exit() [[
        return Completion(Normal);
    ]]
}

operation Jump {
    impl void jump(addr dest) [[
        pc = dest;
    ]]
}

operation IfJump {
    impl void executeIfJump(bool condResult, addr dest) [[
        if (condResult)
            pc = dest;
    ]]

    tile (value, addr) as executeIfJump;
}

operation IfElseJump {
    impl void executeIfElseJump(bool condResult, addr goTrue, addr goFalse) [[
        pc = condResult ? goTrue : goFalse;
    ]]

    tile (value, addr, addr) as executeIfElseJump;
}

// for, while, do ... while, etc., can all be easily expressed as above,
// ditto for continue / break

// ### switch is nasty. Probably needs some opaque pointer type.

operation PopCatch {
    impl void popCatch() [[
        exec->popCatchHandler();
    ]]
}

operation PushCatch {
    impl void pushCatch(addr handler) [[
        exec->pushCatchHandler(handler);
    ]]
}

operation Throw {
    impl void throw(value exception) [[
        exec->setException(exception);
        if (exec->hasCatchHandler())
            pc = exec->takeCatchHandler();
        else
            return Completion(Exception, exception);
    ]]
}

operation Return {
    impl void return (value retVal) [[
        return Completion(Normal, retVal);
    ]]
}

operation ReturnErrorCompletion {
    impl void retErrorCompletion(node node, uint32 errorType, cstr msg) [[
        return node->createErrorCompletion(exec, ErrorType(errorType), msg);
    ]]
}

// Variable stuff... Locals access can just use register addressing,
// not specific get/put, but when we have to do symbolic lookup, we use these.
operation GetVariableObject {
    impl value getVariableObject() [[
        return exec->variableObject();
    ]]
}

operation ScopeLookup {
    // Find which scope the variable is in, e.g. basically evaluates to a reference.
    impl value scopeLookup(ident varName, bool errorOnFailure) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        JSObject *scopeObj;
        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, ident, ref.propertySlot))
                break;
        } while (iter != end);

        if (errorOnFailure && iter == end) {
            // ### TODO: issue error
        }

        $$ = scopeObj;
    ]]
}

operation NonLocalScopeLookup {
    // As above, but may skip one step
    impl value scopeLookup(ident varName, bool errorOnFailure) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        JSObject *scopeObj = *iter;
        if (!scopeObj->isLocalInjected()) {
            // Unless eval introduced new variables dynamically,
            // we know this isn't in the top scope
            ++iter;
        }

        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, ident, ref.propertySlot))
                break;
        } while (iter != end);

        if (errorOnFailure && iter == end) {
            // ### TODO: issue error
        }
        $$ = scopeObj;
    ]]
}


// Looks up a given variable in the scope chain, returns its value
operation LocalVarGet {
    impl value localVarGet(ident varName) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        PropertySlot slot;
        JSObject *scopeObj;
        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, ident, slot)) {
                $$ = slot.getValue(exec, scopeObj, ident);
                break;
            }

            ++iter;
        } while (iter != end);

        if (iter == end)
            throwUndefinedVariableError(exec, ident); //### FIXME
    ]]
}

// Like above, but skips the first step, if possible.
operation NonLocalVarGet {
    impl value nonLocalVarGet(ident varName) [[
        const ScopeChain& chain = exec->scopeChain();
        ScopeChainIterator iter = chain.begin();
        ScopeChainIterator end = chain.end();

        // we must always have something in the scope chain
        assert(iter != end);

        PropertySlot slot;
        JSObject *scopeObj = *iter;

        if (!scopeObj->isLocalInjected()) {
            // Unless eval introduced new variables dynamically,
            // we know this isn't in the top scope
            ++iter;
        }

        do {
            scopeObj = *iter;

            if (scopeObj->getPropertySlot(exec, ident, slot)) {
                $$ = slot.getValue(exec, scopeObj, ident);
                break;
            }

            ++iter;
        } while (iter != end);

        if (iter == end)
            throwUndefinedVariableError(exec, ident);
    ]]
}


operation RegPut {
    impl void regPut(reg destReg, value val) [[
        localStore[destReg].regValue = val;
    ]]
}


// Generic put..
operation SymPut {
    impl void symPut(value scope, ident varName, value val) [[
        base->toObject(exec)->put(varName, val);
    ]]
}

// Put for a scope -- known to be an object!
operation SymPutKnownObject {
    impl void symPutKnownObject(value scope, ident varName, value val) [[
        ASSERT(scope->isObject());
        static_cast<JSObject*>(scope)->put(varName, val);
    ]]
}

// Generic get..
operation SymGet {
    impl value symGet(value base, ident prop) [[
        $$ = base->toObject(exec)->get(exec, prop);
    ]]
}

// Get for a scope -- known to be an object!
operation SymGetKnownObject {
    impl value symScopeGet(value base, ident varName) [[
        ASSERT(scope->isObject());
        $$ = static_cast<JSObject*>(base)->get(exec, varName);
    ]]
}

// Specialization for global object...
operation GlobalSymPut {
    impl void globalSymPut(ident varName, value val) [[
        //### TODO
    ]]
}

operation GlobalSymGet {
    impl value globalGet(ident varName) [[
        //### TODO
    ]]
}

/**
 Binary ops
 */
operation Add1 {
    impl number add1(number old) [[
        $$ = old + 1.0;
    ]]
}

operation Sub1 {
    impl number sub1(number old) [[
        $$ = old - 1.0;
    ]]
}

/**
 Bitops stuff
*/
operation And {
    //### FIXME: this actually distinguishes uin32/int32 --- double-check!
    impl uint32 andOp(uint32 a0, uint32 a1) [[
        $$ = a0 & a1;
    ]]

    tile (reg, value, value) as andOp;
    tile (reg, value, uint32) as andOp;
    tile (reg, uint32, value) as andOp;
}

// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;
