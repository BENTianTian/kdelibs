/*
 *  A utilitity for building various tables and specializations for the
 *  KJS Frostbyte bytecode
 *
 *  Copyright (C) 2007, 2008 Maks Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public License
 *  along with this library; see the file COPYING.LIB.  If not, write to
 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA 02110-1301, USA.
 *
 */

#include "tablebuilder.h"

#include <QFile>
#include <QDir>
#include <QTextStream>
#include <iostream>

QTextStream* makeStream(const QString& fileName, QIODevice::OpenModeFlag flags)
{
    QFile* f = new QFile(fileName);
    if (!f->open(flags)) {
        std::cerr << "Unable to open:" << fileName.toLocal8Bit().data() << "\n";
        return 0;
    }

    return new QTextStream(f);
}

struct FileTemplate
{
    FileTemplate(const QString& inFileName, const QString& outFileName):
        inFileName(inFileName), outFileName(outFileName)
    {
        in  = makeStream(inFileName,  QIODevice::ReadOnly);
        out = makeStream(outFileName, QIODevice::WriteOnly);
        lines = 0;
        if (in && out)
            handlePrefix();
    }

    ~FileTemplate()
    {
        if (in && out)
            handleSuffix();
        delete in;
        delete out;
    }

    // Goes until @generate..
    void handlePrefix()
    {
        *out << "// WARNING: Portions of this file are autogenerated from codes.def and " << inFileName << ".\n";
        *out << "// (which is what the licensing terms apply to)\n";
        *out << "// Any changes you make here may be lost!\n";

        *out << "#line " << 1 << " \"" << inFileName << "\"\n";
        while (!in->atEnd()) {
            QString line = in->readLine();
            ++lines;
            if (line.endsWith("@generate"))
                break;
            else
                *out << line << "\n";
        }
        // This is a little odd since we add 5 lines ourselves --
        // the 3 warning lines, and 2 #lines
        *out << "#line " << (lines + 5) << " \"" << outFileName << "\"\n";
    }

    void handleSuffix()
    {
        *out << "#line " << (lines + 1) << " \"" << inFileName << "\"\n";
        while (!in->atEnd()) {
            QString line = in->readLine();
            *out << line << "\n";
        }
    }

    QString      inFileName;
    QString      outFileName;
    QTextStream* in;
    QTextStream* out;
    bool ok() { return in && out; }
    int lines;

};

int main(int argc, char* argv[])
{
    if (argc != 2) {
        std::cerr << "Usage: tablebuilder <path>\n";
    }

    QString path = QFile::decodeName(argv[1]) + QDir::separator();

    QTextStream* def   = makeStream(path + "codes.def",      QIODevice::ReadOnly);

    FileTemplate opcodesH  (path + "opcodes.h.in",   "opcodes.h");
    FileTemplate opcodesCpp(path + "opcodes.cpp.in", "opcodes.cpp");
    FileTemplate machineCpp(path + "machine.cpp.in", "machine.cpp");

    if (!def || !opcodesH.ok() || !opcodesCpp.ok() || !machineCpp.ok())
        return -1;

    TableBuilder build(def, opcodesH.out, opcodesCpp.out, machineCpp.out);
    build.generateCode();
    return 0;
}

// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on;
