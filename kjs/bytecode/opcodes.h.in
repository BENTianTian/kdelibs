/*
 *  Opcode data structure and selection routines for KJS/Frostbyte
 *  This file is part of the KDE libraries
 *  Copyright (C) 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */


/**
 We use 2 types of encoding here. First of all, we have the
 OpName enum, which species the instruction names, Op_Add, etc.
 There is a structure Op, which specifies a complete instance of this operation,
 with specific parameters, and gives its bytecode, name, etc.
 The bytecode itself is also listed in the OpByteCode_ enum.

 Some instructions also have an aligned version, which skips
 an extra word to get the arguments to be 8-aligned.
*/

namespace KJS {

@generate

struct Op {
    OpName     baseInstr;
    OpByteCode opCode;

    int numParams;
    OpType paramTypes[3];
    bool   immediateParams[3];

    // This array is used to rearrange arguments by alignment;
    // so for example if one does an if: Addr * Addr * Value,
    // the value will be passed in first, then the first and second
    // arguments, so the array will have: 2, 0, 1.
    int paramOrder[3];

    // If this is true, this version of the instruction has an
    // extra word inserted after the opcode, for alignment reasons.
    bool padAlign;
};

// The main array of Op instances, mapped by OpByteCode
extern const Op opsForOpCodes[];

// Lists all the specialized versions of each Op class, mapped by OpName,
// 0 terminated.
typedef const Op* OpInstanceList[];
extern const OpInstanceList* const opSpecializations[];

};

// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on;

