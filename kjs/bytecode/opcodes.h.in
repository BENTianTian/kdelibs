/*
 *  Opcode data structure and selection routines for KJS/Frostbyte
 *  This file is part of the KDE libraries
 *  Copyright (C) 2008 Maksim Orlovich (maksim@kde.org)
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include <wtf/Assertions.h>
    // be nice to our fruity overlords and their silly assert-unfriendly environment
#include <wtf/Vector.h>
#include "value.h"
#include "identifier.h"

namespace KJS {

typedef unsigned Addr;
typedef unsigned Register;

@generate

/**
 There are 2 levels at which instructions exist. First of all, there is
 an actual operation name, represent by the OpName enum. This is something like
 Op_IfJump. For each one of these, we have multiple bytecode instructions, such as
 OpByteCode_IfJump_Ibool_Iaddr and OpByteCode_IfJump_Rbool_Iaddr, with their
 names given in the OpByteCode_ enum.

 For each of these bytecode codes, there is an entry in the opsForOpCodes
 array, which provides an Op structure, which describes which parameters
 go where, and so on. The opSpecializations array lets one look up
 all these structures relevant for each OpName, so one can select
 the specific operation for each conceptual instruction.

 Besides parameter variants, there is also variation based on padding, with
 some bytecodes skipping 4 extra bytes after the opcode to make things 8-aligned.
 Those bytecodes are always 1 below their unaligned version
*/

struct Op {
    OpName     baseInstr;
    OpByteCode opCode;
    int        cost;

    int numParams;
    OpType paramTypes[3];
    bool   immediateParams[3];

    int length; // Length of instruction, including opcode + args

    // This contains offsets of arguments, starting from before the instruction
    int paramOffsets[3];

    // If this is true, this version of the instruction has an
    // extra word inserted after the opcode, for alignment reasons.
    bool padAlign;

    // If this is true, this version has both padded and unpadded flavors
    bool hasPadVariant;
};

// The main array of Op instances, mapped by OpByteCode
extern const Op opsForOpCodes[];

// Lists all the specialized versions of each Op class, mapped by OpName,
// 0 terminated.
extern const Op* const* const opSpecializations[];

// Describes whether the type is align8 or not.
extern const bool opTypeIsAlign8[];

// The NarrowArg and WideArg unions correspond to the encoding of
// 4- and 8-byte arguments in the bytecode.
// Note that the union field names should correspond to codes.def types ---
// type foo will be accessed as fooVal

union NarrowArg
{
    bool     boolVal;
    unsigned uint32Val;
    Addr     addrVal;
    Register regVal;
    unsigned char asBytes[4];
};

union WideArg
{
    JSValue*    valueVal;
    Identifier* identVal;
    UString*    stringVal;
    double      numberVal;
    unsigned char asBytes[8];
};

// This describes a value in the opcode, either
// indirectly via a register, or via
struct OpValue
{
    bool   immediate;
    OpType type;
    union {
        NarrowArg  narrow;
        WideArg    wide;
    } value;
};

typedef Vector<unsigned char> CodeBlock;

class CodeGen {
public:
    // All of these emit the instruction of given type, and return its base
    static OpByteCode* emitOp(CodeBlock& block, OpName baseInstr, OpValue* a0 = 0, OpValue* a1 = 0, OpValue* a2 = 0);

    static inline void patchOpArgument(OpByteCode* base, int pos, OpValue& newVal) {
        const Op& variant = opsForOpCodes[*base];

        // We only permit patching immediate arguments for now..
        ASSERT(variant.immediateParams[pos] && newVal.immediate);

        char* argBase = reinterpret_cast<char*>(base) + variant.paramOffsets[pos];
        if (opTypeIsAlign8[variant.paramTypes[pos]])
            *reinterpret_cast<WideArg*>(argBase) = newVal.value.wide;
        else
            *reinterpret_cast<NarrowArg*>(argBase) = newVal.value.narrow;
    }

    static void disassembleBlock(CodeBlock& block);
private:
    static OpByteCode* emitOp(CodeBlock& block, OpName baseInstr, int numArgs, OpValue* args);
};

} //namespace KJS

// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on; hl c++;

