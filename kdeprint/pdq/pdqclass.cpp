#include "pdqclass.h"

#include <qfile.h>
#include <qcstring.h>

extern BlockT* main_block;

PDQBase::PDQBase()
{
}

PDQBase::PDQBase(const PDQBase& bs)
: name_(bs.name_)
{
}

PDQBase::~PDQBase()
{
}

bool PDQBase::processString(const QString&, const QString&)
{ return false; }

bool PDQBase::processStringList(const QString&, const QStringList&)
{ return false; }

bool PDQBase::processPairList(const QString&, const QMap<QString,QString>&)
{ return false; }

bool PDQBase::processBlock(const QString&, BlockT*)
{ return false; }

void PDQBase::writeToFile(QTextStream&)
{ }

bool PDQBase::readBlock(BlockT *blk)
{
	if (!blk->blocks_) return true;	// no sub-blocks to parse !

	QListIterator<BlockT>	it(*(blk->blocks_));
	bool	flag(true);
	for (;it.current() && flag;++it)
	{
		switch (it.current()->type_)
		{
			case BlockT::String:
				flag = processString(*(it.current()->name_),*(it.current()->values_->first()));
				break;
			case BlockT::StringList:
				{
				  QStringList	l;
				  if (it.current()->values_)
				  {
				  	QListIterator<QString>	lit(*(it.current()->values_));
				  	for (;lit.current();++lit)
						l.append(*(lit.current()));
				  }
				  flag = processStringList(*(it.current()->name_),l);
				}
				break;
			case BlockT::PairList:
				{
				  QMap<QString,QString>	m;
				  if (it.current()->values_)
				  {
				  	QListIterator<QString>	lit(*(it.current()->values_));
				  	for (;lit.current();++lit)
					{
						QString	*s1, *s2;
						s1 = lit.current();
						++lit;
						s2 = lit.current();
						if (s1 && s2) m.insert(*s1,*s2);
					}
				  }
				  flag = processPairList(*(it.current()->name_),m);
				}
				break;
			case BlockT::Block:
				flag = processBlock(*(it.current()->name_),it.current());
/*				if (it.current()->blocks_)
				{
					QListIterator<BlockT>	bit(*(it.current()->blocks_));
					for (;bit.current();++bit)
						flag = flag && processBlock(*(bit.current()->name_),bit.current());
				}*/
				break;
			case BlockT::Null:
				break;
			default:
				flag = false;
				break;
		}
	}
	return flag;
}

//*************************************************************************************************************

PDQMain::PDQMain()
{
	printers_.setAutoDelete(true);
	drivers_.setAutoDelete(true);
	interfaces_.setAutoDelete(true);
	name_ = "Main";
}

PDQMain::~PDQMain()
{
}

bool PDQMain::processString(const QString& name, const QString& value)
{
	if (name == "default_printer") defprinter_ = value;
	else if (name == "interface_command_path") interface_cmd_path_ = value;
	else if (name == "driver_command_path") driver_cmd_path_ = value;
	else if (name == "try_include") tryinclude_.append(value);
	else if (name == "include") include_.append(value);
	else if (name == "job_dir") jobdir_ = value;
	else return false;
	return true;
}

bool PDQMain::processBlock(const QString& name, BlockT *blk)
{
	PDQBase	*item;
	QString	key = (blk->values_ && blk->values_->count() > 0 ? *(blk->values_->first()) : QString::fromLatin1(""));
	if (key.isEmpty())
		return false;	// reject unnamed blocks

	if (name == "printer")
	{
		printers_.replace(key,new PDQPrinter());
		item = printers_.find(key);
	}
	else if (name == "interface")
	{
		interfaces_.replace(key,new PDQInterface());
		item = interfaces_.find(key);
	}
	else if (name == "driver")
	{
		drivers_.replace(key,new PDQDriver());
		item = drivers_.find(key);
	}
	else return false;

	item->setName(key);
	return item->readBlock(blk);
}

void PDQMain::init()
{
	printers_.clear();
	interfaces_.clear();
	drivers_.clear();
	defprinter_ = interface_cmd_path_ = driver_cmd_path_ = QString::null;
}

bool PDQMain::parseFile(const QString& filename, bool expandincl)
{
	if (!QFile::exists(filename))
		return false;

	BlockT	*main_ = pdqParse(filename, expandincl);
	if (main_)
		return readBlock(main_);
	return false;
}

void PDQMain::setPrinter(PDQPrinter *pr)
{
	if (pr) printers_.replace(pr->name(),pr);
}

void PDQMain::writeToFile(QTextStream& t)
{
	// first write some comment
	t << "# File generated by KDEPRINT (PDQ support)." << endl << "# Author Michael Goffioul <goffioul@imec.be>" << endl << endl;

	// write command paths
	if (!interface_cmd_path_.isEmpty()) t << "interface_command_path \"" << interface_cmd_path_ << '"' << endl << endl;
	if (!driver_cmd_path_.isEmpty()) t << "driver_command_path \"" << driver_cmd_path_ << '"' << endl << endl;

	// write potential includes
	for (QStringList::ConstIterator it=tryinclude_.begin(); it!=tryinclude_.end(); ++it)
		t << "try_include \"" << *it << '"' << endl;
	t << endl;
	for (QStringList::ConstIterator it=include_.begin(); it!=include_.end(); ++it)
		t << "include \"" << *it << '"' << endl;
	t << endl;

	// default printer
	if (!defprinter_.isEmpty()) t << "default_printer \"" << defprinter_ << '"' << endl << endl;

	// printers
	QDictIterator<PDQPrinter>	it1(printers_);
	for (;it1.current();++it1)
		it1.current()->writeToFile(t);
	// drivers
	QDictIterator<PDQDriver>	it2(drivers_);
	for (;it2.current();++it2)
		it2.current()->writeToFile(t);
	// interfaces
	QDictIterator<PDQInterface>	it3(interfaces_);
	for (;it3.current();++it3)
		it3.current()->writeToFile(t);
}

bool PDQMain::saveFile(const QString& filename)
{
	QFile	f(filename);
	if (f.open(IO_WriteOnly))
	{
		QTextStream	t(&f);
		writeToFile(t);
		return true;
	}
	else
		return false;
}

//*************************************************************************************************************

PDQPrinter::PDQPrinter()
{
}

PDQPrinter::PDQPrinter(const PDQPrinter& pr)
: PDQBase(pr), interface_(pr.interface_), driver_(pr.driver_), model_(pr.model_), location_(pr.location_),
  driver_options_(pr.driver_options_), interface_options_(pr.interface_options_), driver_args_(pr.driver_args_),
  interface_args_(pr.interface_args_)
{
}

PDQPrinter::~PDQPrinter()
{
}

PDQPrinter* PDQPrinter::duplicate()
{
	return new PDQPrinter(*this);
}

bool PDQPrinter::processString(const QString& name, const QString& value)
{
	if (name == "interface") interface_ = value;
	else if (name == "driver") driver_ = value;
	else if (name == "model") model_ = value;
	else if (name == "location") location_ = value;
	else return false;
	return true;
}

bool PDQPrinter::processStringList(const QString& name, const QStringList& values)
{
	if (name == "driver_opts") driver_options_ = values;
	else if (name == "interface_opts") interface_options_ = values;
	else return false;
	return true;
}

bool PDQPrinter::processPairList(const QString& name, const QMap<QString,QString>& pairs)
{
	if (name == "driver_args") driver_args_ = pairs;
	else if (name == "interface_args") interface_args_ = pairs;
	else return false;
	return true;
}

void PDQPrinter::writeToFile(QTextStream& t)
{
	// header
	t << "printer \"" << name() << "\" {" << endl;
	// useful infos
	if (!model_.isEmpty()) t << "\tmodel \"" << model_ << '"' << endl;
	if (!location_.isEmpty()) t << "\tlocation \"" << location_ << '"' << endl;
	// needed infos
	t << "\tinterface \"" << interface_ << '"' << endl;
	t << "\tdriver \"" << driver_ << '"' << endl;
	// driver options
	t << "\tdriver_opts { ";
	for (QStringList::ConstIterator it=driver_options_.begin(); it!=driver_options_.end();)
	{
		t << '"' << *it << '"';
		if (++it != driver_options_.end()) t << ", ";
	}
	t << " }" << endl;
	// driver arguments
	t << "\tdriver_args { ";
	for (QMap<QString,QString>::ConstIterator it=driver_args_.begin(); it!=driver_args_.end();)
	{
		t << '"' << it.key() << "\" = \"" << it.data() << '"';
		if (++it != driver_args_.end()) t << ", ";
	}
	t << " }" << endl;
	// interface options
	t << "\tinterface_opts { ";
	for (QStringList::ConstIterator it=interface_options_.begin(); it!=interface_options_.end();)
	{
		t << '"' << *it << '"';
		if (++it != interface_options_.end()) t << ", ";
	}
	t << " }" << endl;
	// interface arguments
	t << "\tinterface_args { ";
	for (QMap<QString,QString>::ConstIterator it=interface_args_.begin(); it!=interface_args_.end();)
	{
		t << '"' << it.key() << "\" = \"" << it.data() << '"';
		if (++it != interface_args_.end()) t << ", ";
	}
	t << " }" << endl;
	// closing brace
	t << '}' << endl << endl;
}

//*************************************************************************************************************

PDQInterface::PDQInterface()
{
	arguments_.setAutoDelete(true);
	options_.setAutoDelete(true);
}

PDQInterface::~PDQInterface()
{
}

bool PDQInterface::processString(const QString& name, const QString& value)
{
	if (name == "verify_exec") verify_ = value;
	else if (name == "send_exec") send_ = value;
	else if (name == "status_exec") status_ = value;
	else if (name == "cancel_exec") cancel_ = value;
	else if (name == "help") help_ = value;
	else return false;
	return true;
}

bool PDQInterface::processStringList(const QString& name, const QStringList& values)
{
	if (name == "required_args") required_args_ = values;
	else if (name == "requires") requires_ = values;
	else return false;
	return true;
}

bool PDQInterface::processBlock(const QString& name, BlockT *blk)
{
	PDQBase	*item;
	if (name == "argument")
	{
		arguments_.append(new PDQArgument());
		item = arguments_.last();
	}
	else if (name == "option")
	{
		options_.append(new PDQOption());
		item = options_.last();
	}
	else return false;

	if (blk->values_ && blk->values_->count() > 0) item->setName(*(blk->values_->first()));
	return item->readBlock(blk);
}

//*************************************************************************************************************

PDQDriver::PDQDriver()
{
	arguments_.setAutoDelete(true);
	options_.setAutoDelete(true);
	language_drivers_.setAutoDelete(true);
}

PDQDriver::~PDQDriver()
{
}

bool PDQDriver::processString(const QString& name, const QString& value)
{
	if (name == "verify_exec") verify_ = value;
	else if (name == "filter_exec") filter_ = value;
	else if (name == "filetype_exec") filetype_ = value;
	else if (name == "help") help_ = value;
	else return false;
	return true;
}

bool PDQDriver::processStringList(const QString& name, const QStringList& values)
{
	if (name == "required_args") required_args_ = values;
	else if (name == "requires") requires_ = values;
	else return false;
	return true;
}

bool PDQDriver::processBlock(const QString& name, BlockT *blk)
{
	PDQBase	*item;
	if (name == "argument")
	{
		arguments_.append(new PDQArgument());
		item = arguments_.last();
	}
	else if (name == "option")
	{
		options_.append(new PDQOption());
		item = options_.last();
	}
	else if (name == "language_driver")
	{
		language_drivers_.append(new PDQFilter());
		item = language_drivers_.last();
	}
	else return false;

	if (blk->values_ && blk->values_->count() > 0) item->setName(*(blk->values_->first()));
	return item->readBlock(blk);
}

//*************************************************************************************************************

PDQArgument::PDQArgument()
{
}

PDQArgument::~PDQArgument()
{
}

bool PDQArgument::processString(const QString& name, const QString& value)
{
	if (name == "def_value") defvalue_ = value;
	else if (name == "desc") description_ = value;
	else if (name == "help") help_ = value;
	else if (name == "var") setName(value);
	else return false;
	return true;
}

//*************************************************************************************************************

PDQChoice::PDQChoice()
{
}

PDQChoice::~PDQChoice()
{
}

bool PDQChoice::processString(const QString& name, const QString& value)
{
	if (name == "value") value_ = value;
	else if (name == "desc") description_ = value;
	else if (name == "help") help_ = value;
	else return false;
	return true;
}

//*************************************************************************************************************

PDQOption::PDQOption()
{
	choices_.setAutoDelete(true);
}

PDQOption::~PDQOption()
{
}

bool PDQOption::processString(const QString& name, const QString& value)
{
	if (name == "var") setName(value);
	else if (name == "desc") description_ = value;
	else if (name == "default_choice") default_choice_ = value;
	else return false;
	return true;
}

bool PDQOption::processBlock(const QString& name, BlockT *blk)
{
	PDQBase	*item;
	if (name == "choice")
	{
		choices_.append(new PDQChoice());
		item = choices_.last();
	}
	else return false;

	if (blk->values_ && blk->values_->count() > 0) item->setName(*(blk->values_->first()));
	return item->readBlock(blk);
}

//*************************************************************************************************************

PDQFilter::PDQFilter()
{
}

PDQFilter::~PDQFilter()
{
}

bool PDQFilter::processString(const QString& name, const QString& value)
{
	if (name == "filetype_regx") filetype_regx_ = value;
	else if (name == "convert_exec") convert_ = value;
	else return false;
	return true;
}
