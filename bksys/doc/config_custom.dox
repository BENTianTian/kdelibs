/** \page config_custom custom configuring 

\ref proposal_state

What means custom configuring: \n 
developers would like to be able to define "configure needs" in subdirs of a svn module,
i.e. to have a file under kdecore that says "I need the headers sys/stat.h, sys/mntent.h, 
sys/param.h, paths.h, limits.h, execinfo.h" etc. and I need the c functions "mmap, getmntinfo, 
setmntent", etc. 

Custom configuration means that developers can customize the configure process on a 
package or directory related way. 

\section package_based_config_checks Package based config checks

Package related cofigurations are provided by specific python modules located in the bksys directory like 

- libz.py 
- libpng.py 
- libagg.py 
- kde4.py 

and others. They are using the \ref scons_config_checks api and are activated by adding the related 
python module in the 'module' attribute of the SConstruct config array. 

\section scons_config_checks scons provided config checks 
Scons provides some prefined checks:  
\code
conf.CheckHeader('math.h')
conf.CheckCHeader('math.h')
conf.CheckCXXHeader('vector.h')
conf.CheckFunc('strcpy')
conf.CheckLib('m')
conf.CheckLibWithHeader('m', 'math.h')
conf.CheckType('off_t')
conf.CheckType('off_t', '#include <sys/types.h>\n'):
\endcode 

Those tests are performed mostly like shown below: 
\code 
if not conf.CheckType('off_t', '#include <sys/types.h>\n'):
  	conf.env.Append(CCFLAGS = '-Doff_t=int')
\endcode
This example adds a specific preprocessor macro in case the type wasn't found. You may inspect the provided 
python modules in the bksys dir for further informations. 

\section directory_based_config_checks Directory based config checks

The directory based config checks works by adding specific files named 'SConfigure' into the required 
directory (like autotool's directory based configure.in.in). \n
On the configuring process the settings in this files are collected and stored in the 
\ref config_cache. Then the configuration process performs the requested 
actions, that means searching for headers, c function and additional libraries. The results are 
stored into the configuration cache too. 
	
\section sconfigure_format Format of 'SConfigure' files

SConfigure files are regular python scripts which are executed by the configure process with a 
previously created PackageConfigure object named 'conf'. 
The PackageConfigure class provides several attributes, which allows to customize the configuration. 

\code 
if not conf.CheckType('off_t', '#include <sys/types.h>\n'):
  	conf.env.Append(CCFLAGS = '-Doff_t=int')
\endcode

------
The provided functions uses the same prototypes as the scons based tests. 
KDE sources uses the autotools \ref config_header feature, which has to be supported by bksys too. 
For this purpose some additional functions are available: 
------


\subsection config_set_config_header specifiy used config header file
example: 

\code
conf.setConfigHeader("config-dcop.h")
\endcode

\subsection config_check_header specify required c header file(s)
example:

\code
conf.checkHeaders('sys/time.h unistd.h')
conf.checkHeaders(['sys/time.h', 'unistd.h'])
\endcode

If the header file wasn't found while configuration, a warning is printed and the configuration process goes on.

the given filenames are automatically mapped to a related define in the config header config-<dirname>.h 
which is included by the global config.h file. \n 
If for example the header sys/stat.h is present it will be mapped to HAVE_SYS_STAT_H \n

\subsection config_check_function specify required c function(s)
example: 

\code
conf.checkFunc('setenv gethostname')
conf.checkFunc(['setenv','gethostname'])
\endcode

If the header file wasn't found while configuration, a warning is printed and the configuration process goes on.

The available functions are mapped automatically to a related define in the related config header which is included 
by the global config.h file. \n
if for example the function strlcpy() is present it will be mapped to HAVE_STRLCPY \n


\subsection config_check_module check a predefined package
This function calls a predefined config check described in \ref package_based_config_checks

\code
conf.checkModule('libbz2'):
conf.checkModule('openssl'):
\endcode

\code
if env.has_key['CACHED_LIBBZ2']: 
	obj.source += "xxx"
	obj.includes  += env.['CXXFLAGS_LIBBZ2']
	obj.linkflags += env.['LINKFLAGS_LIBBZ2']
\endcode


\section Implementation hints 

- put in here requirements/options for the implementation 


\section custom_config_notes notes
- later on we could then even automate the creation of that file by a script
that scans the source files for those headers and functions, but not at compile
time imho, just as an easy way to keep those files in sync

- But we can include in the recursive lookup a way to look for _<PLATFORM> files 
additionally, so we can have both.

- we might want per-subdir .h files (e.g. config-kdecore.h and config-kdeui.h), so that
it's easier to move a subdir to another module... but then we have to run the same tests 
more than once if both kdecore and kdeui need sys/stat.h. Although, with the caching
it would be fast, just a bit strange on stdout.

*/
