/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#include "core.h"

// Implementation
Header::Header()
{
}

Header::Header(HeaderMagic magic, long messageLength, MessageType messageType)
{
	this->magic = magic;
	this->messageLength = messageLength;
	this->messageType = messageType;
}

Header::Header(Buffer& stream)
{
	readType(stream);
}

Header::Header(const Header& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Header& Header::operator=(const Header& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

Header::~Header()
{
}

void Header::readType(Buffer& stream)
{
	magic = (HeaderMagic)stream.readLong();
	messageLength = stream.readLong();
	messageType = (MessageType)stream.readLong();
}

void Header::writeType(Buffer& stream) const
{
	stream.writeLong(magic);
	stream.writeLong(messageLength);
	stream.writeLong(messageType);
}

Invocation::Invocation()
{
}

Invocation::Invocation(long requestID, long objectID, long methodID)
{
	this->requestID = requestID;
	this->objectID = objectID;
	this->methodID = methodID;
}

Invocation::Invocation(Buffer& stream)
{
	readType(stream);
}

Invocation::Invocation(const Invocation& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Invocation& Invocation::operator=(const Invocation& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

Invocation::~Invocation()
{
}

void Invocation::readType(Buffer& stream)
{
	requestID = stream.readLong();
	objectID = stream.readLong();
	methodID = stream.readLong();
}

void Invocation::writeType(Buffer& stream) const
{
	stream.writeLong(requestID);
	stream.writeLong(objectID);
	stream.writeLong(methodID);
}

ServerHello::ServerHello()
{
}

ServerHello::ServerHello(const string& serverID, const vector<string>& authProtocols, const string& authSeed)
{
	this->serverID = serverID;
	this->authProtocols = authProtocols;
	this->authSeed = authSeed;
}

ServerHello::ServerHello(Buffer& stream)
{
	readType(stream);
}

ServerHello::ServerHello(const ServerHello& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

ServerHello& ServerHello::operator=(const ServerHello& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

ServerHello::~ServerHello()
{
}

void ServerHello::readType(Buffer& stream)
{
	stream.readString(serverID);
	stream.readStringSeq(authProtocols);
	stream.readString(authSeed);
}

void ServerHello::writeType(Buffer& stream) const
{
	stream.writeString(serverID);
	stream.writeStringSeq(authProtocols);
	stream.writeString(authSeed);
}

ClientHello::ClientHello()
{
}

ClientHello::ClientHello(const string& serverID, const string& authProtocol, const string& authData)
{
	this->serverID = serverID;
	this->authProtocol = authProtocol;
	this->authData = authData;
}

ClientHello::ClientHello(Buffer& stream)
{
	readType(stream);
}

ClientHello::ClientHello(const ClientHello& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

ClientHello& ClientHello::operator=(const ClientHello& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

ClientHello::~ClientHello()
{
}

void ClientHello::readType(Buffer& stream)
{
	stream.readString(serverID);
	stream.readString(authProtocol);
	stream.readString(authData);
}

void ClientHello::writeType(Buffer& stream) const
{
	stream.writeString(serverID);
	stream.writeString(authProtocol);
	stream.writeString(authData);
}

ObjectReference::ObjectReference()
{
}

ObjectReference::ObjectReference(const string& serverID, long objectID, const vector<string>& urls)
{
	this->serverID = serverID;
	this->objectID = objectID;
	this->urls = urls;
}

ObjectReference::ObjectReference(Buffer& stream)
{
	readType(stream);
}

ObjectReference::ObjectReference(const ObjectReference& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

ObjectReference& ObjectReference::operator=(const ObjectReference& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

ObjectReference::~ObjectReference()
{
}

void ObjectReference::readType(Buffer& stream)
{
	stream.readString(serverID);
	objectID = stream.readLong();
	stream.readStringSeq(urls);
}

void ObjectReference::writeType(Buffer& stream) const
{
	stream.writeString(serverID);
	stream.writeLong(objectID);
	stream.writeStringSeq(urls);
}

ParamDef::ParamDef()
{
}

ParamDef::ParamDef(const string& type, const string& name)
{
	this->type = type;
	this->name = name;
}

ParamDef::ParamDef(Buffer& stream)
{
	readType(stream);
}

ParamDef::ParamDef(const ParamDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

ParamDef& ParamDef::operator=(const ParamDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

ParamDef::~ParamDef()
{
}

void ParamDef::readType(Buffer& stream)
{
	stream.readString(type);
	stream.readString(name);
}

void ParamDef::writeType(Buffer& stream) const
{
	stream.writeString(type);
	stream.writeString(name);
}

MethodDef::MethodDef()
{
}

MethodDef::MethodDef(const string& name, const string& type, long flags, const vector<ParamDef *>& signature)
{
	this->name = name;
	this->type = type;
	this->flags = flags;
	this->signature = signature;
}

MethodDef::MethodDef(Buffer& stream)
{
	readType(stream);
}

MethodDef::MethodDef(const MethodDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

MethodDef& MethodDef::operator=(const MethodDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

MethodDef::~MethodDef()
{
	freeTypeSeq<ParamDef>(signature);
}

void MethodDef::readType(Buffer& stream)
{
	stream.readString(name);
	stream.readString(type);
	flags = stream.readLong();
	readTypeSeq<ParamDef>(stream,signature);
}

void MethodDef::writeType(Buffer& stream) const
{
	stream.writeString(name);
	stream.writeString(type);
	stream.writeLong(flags);
	writeTypeSeq<ParamDef>(stream,signature);
}

AttributeDef::AttributeDef()
{
}

AttributeDef::AttributeDef(const string& name, const string& type, AttributeType flags)
{
	this->name = name;
	this->type = type;
	this->flags = flags;
}

AttributeDef::AttributeDef(Buffer& stream)
{
	readType(stream);
}

AttributeDef::AttributeDef(const AttributeDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

AttributeDef& AttributeDef::operator=(const AttributeDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

AttributeDef::~AttributeDef()
{
}

void AttributeDef::readType(Buffer& stream)
{
	stream.readString(name);
	stream.readString(type);
	flags = (AttributeType)stream.readLong();
}

void AttributeDef::writeType(Buffer& stream) const
{
	stream.writeString(name);
	stream.writeString(type);
	stream.writeLong(flags);
}

InterfaceDef::InterfaceDef()
{
}

InterfaceDef::InterfaceDef(const string& name, const vector<string>& inheritedInterfaces, const vector<MethodDef *>& methods, const vector<AttributeDef *>& attributes)
{
	this->name = name;
	this->inheritedInterfaces = inheritedInterfaces;
	this->methods = methods;
	this->attributes = attributes;
}

InterfaceDef::InterfaceDef(Buffer& stream)
{
	readType(stream);
}

InterfaceDef::InterfaceDef(const InterfaceDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

InterfaceDef& InterfaceDef::operator=(const InterfaceDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

InterfaceDef::~InterfaceDef()
{
	freeTypeSeq<MethodDef>(methods);
	freeTypeSeq<AttributeDef>(attributes);
}

void InterfaceDef::readType(Buffer& stream)
{
	stream.readString(name);
	stream.readStringSeq(inheritedInterfaces);
	readTypeSeq<MethodDef>(stream,methods);
	readTypeSeq<AttributeDef>(stream,attributes);
}

void InterfaceDef::writeType(Buffer& stream) const
{
	stream.writeString(name);
	stream.writeStringSeq(inheritedInterfaces);
	writeTypeSeq<MethodDef>(stream,methods);
	writeTypeSeq<AttributeDef>(stream,attributes);
}

TypeComponent::TypeComponent()
{
}

TypeComponent::TypeComponent(const string& type, const string& name)
{
	this->type = type;
	this->name = name;
}

TypeComponent::TypeComponent(Buffer& stream)
{
	readType(stream);
}

TypeComponent::TypeComponent(const TypeComponent& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

TypeComponent& TypeComponent::operator=(const TypeComponent& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

TypeComponent::~TypeComponent()
{
}

void TypeComponent::readType(Buffer& stream)
{
	stream.readString(type);
	stream.readString(name);
}

void TypeComponent::writeType(Buffer& stream) const
{
	stream.writeString(type);
	stream.writeString(name);
}

TypeDef::TypeDef()
{
}

TypeDef::TypeDef(const string& name, const vector<TypeComponent *>& contents)
{
	this->name = name;
	this->contents = contents;
}

TypeDef::TypeDef(Buffer& stream)
{
	readType(stream);
}

TypeDef::TypeDef(const TypeDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

TypeDef& TypeDef::operator=(const TypeDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

TypeDef::~TypeDef()
{
	freeTypeSeq<TypeComponent>(contents);
}

void TypeDef::readType(Buffer& stream)
{
	stream.readString(name);
	readTypeSeq<TypeComponent>(stream,contents);
}

void TypeDef::writeType(Buffer& stream) const
{
	stream.writeString(name);
	writeTypeSeq<TypeComponent>(stream,contents);
}

EnumComponent::EnumComponent()
{
}

EnumComponent::EnumComponent(const string& name, long value)
{
	this->name = name;
	this->value = value;
}

EnumComponent::EnumComponent(Buffer& stream)
{
	readType(stream);
}

EnumComponent::EnumComponent(const EnumComponent& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

EnumComponent& EnumComponent::operator=(const EnumComponent& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

EnumComponent::~EnumComponent()
{
}

void EnumComponent::readType(Buffer& stream)
{
	stream.readString(name);
	value = stream.readLong();
}

void EnumComponent::writeType(Buffer& stream) const
{
	stream.writeString(name);
	stream.writeLong(value);
}

EnumDef::EnumDef()
{
}

EnumDef::EnumDef(const string& name, const vector<EnumComponent *>& contents)
{
	this->name = name;
	this->contents = contents;
}

EnumDef::EnumDef(Buffer& stream)
{
	readType(stream);
}

EnumDef::EnumDef(const EnumDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

EnumDef& EnumDef::operator=(const EnumDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

EnumDef::~EnumDef()
{
	freeTypeSeq<EnumComponent>(contents);
}

void EnumDef::readType(Buffer& stream)
{
	stream.readString(name);
	readTypeSeq<EnumComponent>(stream,contents);
}

void EnumDef::writeType(Buffer& stream) const
{
	stream.writeString(name);
	writeTypeSeq<EnumComponent>(stream,contents);
}

ModuleDef::ModuleDef()
{
}

ModuleDef::ModuleDef(const string& moduleName, const vector<ModuleDef *>& modules, const vector<EnumDef *>& enums, const vector<TypeDef *>& types, const vector<InterfaceDef *>& interfaces)
{
	this->moduleName = moduleName;
	this->modules = modules;
	this->enums = enums;
	this->types = types;
	this->interfaces = interfaces;
}

ModuleDef::ModuleDef(Buffer& stream)
{
	readType(stream);
}

ModuleDef::ModuleDef(const ModuleDef& copyType) :Type()
{
	Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

ModuleDef& ModuleDef::operator=(const ModuleDef& assignType)
{
	Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

ModuleDef::~ModuleDef()
{
	freeTypeSeq<ModuleDef>(modules);
	freeTypeSeq<EnumDef>(enums);
	freeTypeSeq<TypeDef>(types);
	freeTypeSeq<InterfaceDef>(interfaces);
}

void ModuleDef::readType(Buffer& stream)
{
	stream.readString(moduleName);
	readTypeSeq<ModuleDef>(stream,modules);
	readTypeSeq<EnumDef>(stream,enums);
	readTypeSeq<TypeDef>(stream,types);
	readTypeSeq<InterfaceDef>(stream,interfaces);
}

void ModuleDef::writeType(Buffer& stream) const
{
	stream.writeString(moduleName);
	writeTypeSeq<ModuleDef>(stream,modules);
	writeTypeSeq<EnumDef>(stream,enums);
	writeTypeSeq<TypeDef>(stream,types);
	writeTypeSeq<InterfaceDef>(stream,interfaces);
}

InterfaceRepo *InterfaceRepo::_fromString(string objectref)
{
	InterfaceRepo *result = 0;
	ObjectReference r;

	if(Dispatcher::the()->stringToObjectReference(r,objectref))
	{
		result = (InterfaceRepo *)Dispatcher::the()->connectObjectLocal(r,"InterfaceRepo");
		if(!result)
		{
			Connection *conn = Dispatcher::the()->connectObjectRemote(r);
			if(conn)
				result = new InterfaceRepo_stub(conn,r.objectID);
		}
	}
	return result;
}

InterfaceRepo_stub::InterfaceRepo_stub()
{
	// constructor for subclasses (don't use directly)
}

InterfaceRepo_stub::InterfaceRepo_stub(Connection *connection, long objectID)
	: Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

long InterfaceRepo_stub::insertModule(const ModuleDef& newModule)
{
	long methodID = _lookupMethodFast("method:0d000000696e736572744d6f64756c6500050000006c6f6e670000000000010000000a0000004d6f64756c65446566000a0000006e65774d6f64756c6500");
	long requestID;
	Buffer *request, *result;
	request = Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	// methodID = 3  =>  insertModule
	newModule.writeType(*request);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Dispatcher::the()->waitForResult(requestID);
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void InterfaceRepo_stub::removeModule(long moduleID)
{
	long methodID = _lookupMethodFast("method:0d00000072656d6f76654d6f64756c650005000000766f6964000000000001000000050000006c6f6e6700090000006d6f64756c65494400");
	long requestID;
	Buffer *request, *result;
	request = Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	// methodID = 4  =>  removeModule
	request->writeLong(moduleID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Dispatcher::the()->waitForResult(requestID);
	delete result;
}

InterfaceDef* InterfaceRepo_stub::queryInterface(const string& name)
{
	long methodID = _lookupMethodFast("method:0f0000007175657279496e74657266616365000d000000496e7465726661636544656600000000000100000007000000737472696e6700050000006e616d6500");
	long requestID;
	Buffer *request, *result;
	request = Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	// methodID = 5  =>  queryInterface
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Dispatcher::the()->waitForResult(requestID);
	InterfaceDef *_returnCode = new InterfaceDef(*result);
	delete result;
	return _returnCode;
}

TypeDef* InterfaceRepo_stub::queryType(const string& name)
{
	long methodID = _lookupMethodFast("method:0a00000071756572795479706500080000005479706544656600000000000100000007000000737472696e6700050000006e616d6500");
	long requestID;
	Buffer *request, *result;
	request = Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	// methodID = 6  =>  queryType
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Dispatcher::the()->waitForResult(requestID);
	TypeDef *_returnCode = new TypeDef(*result);
	delete result;
	return _returnCode;
}

string InterfaceRepo_skel::_interfaceName()
{
	return "InterfaceRepo";
}

string InterfaceRepo_skel::_interfaceNameSkel()
{
	return "InterfaceRepo";
}

void *InterfaceRepo_skel::_cast(string interface)
{
	if(interface == "InterfaceRepo") return (InterfaceRepo *)this;
	return 0;
}

// insertModule
static void _dispatch_InterfaceRepo_00(void *object, Buffer *request, Buffer *result)
{
	ModuleDef newModule(*request);
	result->writeLong(((InterfaceRepo_skel *)object)->insertModule(newModule));
}

// removeModule
static void _dispatch_InterfaceRepo_01(void *object, Buffer *request, Buffer *)
{
	long moduleID = request->readLong();
	((InterfaceRepo_skel *)object)->removeModule(moduleID);
}

// queryInterface
static void _dispatch_InterfaceRepo_02(void *object, Buffer *request, Buffer *result)
{
	string name;
	request->readString(name);
	InterfaceDef *_returnCode = ((InterfaceRepo_skel *)object)->queryInterface(name);
	_returnCode->writeType(*result);
	delete _returnCode;
}

// queryType
static void _dispatch_InterfaceRepo_03(void *object, Buffer *request, Buffer *result)
{
	string name;
	request->readString(name);
	TypeDef *_returnCode = ((InterfaceRepo_skel *)object)->queryType(name);
	_returnCode->writeType(*result);
	delete _returnCode;
}

void InterfaceRepo_skel::_buildMethodTable()
{
	Buffer m;
	m.fromString("MethodTable:0d000000696e736572744d6f64756c6500050000006c6f6e670000000000010000000a0000004d6f64756c65446566000a0000006e65774d6f64756c65000d00000072656d6f76654d6f64756c650005000000766f6964000000000001000000050000006c6f6e6700090000006d6f64756c654944000f0000007175657279496e74657266616365000d000000496e7465726661636544656600000000000100000007000000737472696e6700050000006e616d65000a00000071756572795479706500080000005479706544656600000000000100000007000000737472696e6700050000006e616d6500","MethodTable");
	_addMethod(_dispatch_InterfaceRepo_00,this,MethodDef(m));
	_addMethod(_dispatch_InterfaceRepo_01,this,MethodDef(m));
	_addMethod(_dispatch_InterfaceRepo_02,this,MethodDef(m));
	_addMethod(_dispatch_InterfaceRepo_03,this,MethodDef(m));
}

InterfaceRepo_skel::InterfaceRepo_skel()
{
}

IDLFileReg IDLFileReg_core("core","IDLFile:010000000000000000030000000c0000004865616465724d6167696300010000000b0000004d434f505f4d41474943004d434f500c0000004d6573736167655479706500050000000f0000006d636f70496e766f636174696f6e00010000000b0000006d636f7052657475726e0002000000100000006d636f7053657276657248656c6c6f0003000000100000006d636f70436c69656e7448656c6c6f00040000000f0000006d636f704175746841636365707400050000000e0000004174747269627574655479706500050000000900000073747265616d496e00010000000a00000073747265616d4f757400020000000c00000073747265616d4d756c746900040000001000000061747472696275746553747265616d00080000001300000061747472696275746541747472696275746500100000000e0000000700000048656164657200030000000c0000004865616465724d6167696300060000006d6167696300050000006c6f6e67000e0000006d6573736167654c656e677468000c0000004d65737361676554797065000c0000006d65737361676554797065000b000000496e766f636174696f6e0003000000050000006c6f6e67000a00000072657175657374494400050000006c6f6e6700090000006f626a656374494400050000006c6f6e6700090000006d6574686f644944000c00000053657276657248656c6c6f000300000007000000737472696e670009000000736572766572494400080000002a737472696e67000e0000006175746850726f746f636f6c730007000000737472696e6700090000006175746853656564000c000000436c69656e7448656c6c6f000300000007000000737472696e67000900000073657276657249440007000000737472696e67000d0000006175746850726f746f636f6c0007000000737472696e670009000000617574684461746100100000004f626a6563745265666572656e6365000300000007000000737472696e670009000000736572766572494400050000006c6f6e6700090000006f626a656374494400080000002a737472696e67000500000075726c730009000000506172616d446566000200000007000000737472696e670005000000747970650007000000737472696e6700050000006e616d65000a0000004d6574686f64446566000400000007000000737472696e6700050000006e616d650007000000737472696e6700050000007479706500050000006c6f6e670006000000666c616773000a0000002a506172616d446566000a0000007369676e6174757265000d000000417474726962757465446566000300000007000000737472696e6700050000006e616d650007000000737472696e67000500000074797065000e000000417474726962757465547970650006000000666c616773000d000000496e74657266616365446566000400000007000000737472696e6700050000006e616d6500080000002a737472696e670014000000696e68657269746564496e7465726661636573000b0000002a4d6574686f6444656600080000006d6574686f6473000e0000002a417474726962757465446566000b00000061747472696275746573000e00000054797065436f6d706f6e656e74000200000007000000737472696e670005000000747970650007000000737472696e6700050000006e616d65000800000054797065446566000200000007000000737472696e6700050000006e616d65000f0000002a54797065436f6d706f6e656e740009000000636f6e74656e7473000e000000456e756d436f6d706f6e656e74000200000007000000737472696e6700050000006e616d6500050000006c6f6e67000600000076616c75650008000000456e756d446566000200000007000000737472696e6700050000006e616d65000f0000002a456e756d436f6d706f6e656e740009000000636f6e74656e7473000a0000004d6f64756c65446566000500000007000000737472696e67000b0000006d6f64756c654e616d65000b0000002a4d6f64756c6544656600080000006d6f64756c657300090000002a456e756d4465660006000000656e756d7300090000002a5479706544656600060000007479706573000e0000002a496e74657266616365446566000b000000696e746572666163657300010000000e000000496e746572666163655265706f0000000000040000000d000000696e736572744d6f64756c6500050000006c6f6e670000000000010000000a0000004d6f64756c65446566000a0000006e65774d6f64756c65000d00000072656d6f76654d6f64756c650005000000766f6964000000000001000000050000006c6f6e6700090000006d6f64756c654944000f0000007175657279496e74657266616365000d000000496e7465726661636544656600000000000100000007000000737472696e6700050000006e616d65000a00000071756572795479706500080000005479706544656600000000000100000007000000737472696e6700050000006e616d650000000000");
