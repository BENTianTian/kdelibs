/*

    Copyright (C) 1999-2000 Stefan Westerfeld
                       stefan@space.twc.de

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.
  
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
   
    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.

*/

// MCOP protocol

enum HeaderMagic { MCOP_MAGIC = 0x504f434d }; /* gets marshalled as "MCOP" */

enum MessageType {
 mcopInvocation  = 1,
 mcopReturn      = 2,
 mcopServerHello = 3,
 mcopClientHello = 4,
 mcopAuthAccept  = 5,
 mcopOnewayInvocation  = 6
};

/**
 * This type is sent as header of each MCOP message.
 */
struct Header {
	/**
	 * the value 0x504f434d, which is marshalled as MCOP
	 */
    HeaderMagic magic;
    long messageLength;
    MessageType messageType;
};

/**
 * This is sent as start of each normal (twoway) invocation
 */
struct Invocation {
	/**
	 * A unique number of the request (needed to send the return code back)
	 */
    long requestID;
	/**
	 * The ID of the object receiving the request
	 */
    long objectID;
	/**
	 * The ID of the method that is to be invoked
	 */
    long methodID;
};

/**
 * This is sent as start of each oneway invocation
 */
struct OnewayInvocation {
	/**
	 * The ID of the object receiving the request
	 */
    long objectID;
	/**
	 * The ID of the method that is to be invoked
	 */
    long methodID;
};

/**
 * Body of the mcopServerHello MCOP message
 */
struct ServerHello {
	string serverID;
	sequence<string> authProtocols;
	string authSeed;
};

/**
 * Body of the mcopClientHello MCOP message
 */
struct ClientHello {
	string serverID;
	string authProtocol;
	string authData;
};

/**
 * An object reference
 */
struct ObjectReference {
	/**
	 * A unique ID for the server the object is located on, (a server ID may
	 * i.e. be composed of start time, hostname, and pid)
	 */
	string serverID;

	/**
	 * The number of the object under that server
	 */
	long objectID;

	/**
	 * where the server holding object can be reached
	 */
	sequence<string> urls;
};

// Interface definitions

/**
 * The definition of a parameter of a method
 */
struct ParamDef {
	string type;
	string name;
};

/**
 * Twoway methods are such where the calling process does a call and is
 * suspended until some result (maybe even a void result) gets back.
 *
 * Oneway methods are one shot and forget methods: you send the invocation,
 * and continue. Maybe it will be received, maybe executed later. You will
 * never hear the result.
 */
enum MethodType {
	methodOneway = 1,
	methodTwoway = 2
};

/**
 * The definition of a method.
 */
struct MethodDef {
	string     name;
	string     type;
	MethodType flags;

	sequence<ParamDef> signature;
};

/**
 * an attribute
 *
 * flags should contain things like
 *
 * @li attribute is readonly/writeonly/readwrite
 * @li attribute is incoming/outgoing stream
 * @li if it's a stream, it also should contain the information whether it is
 *     asynchronous or synchronous
 * @li NB20000320: see InterfaceDef for the meaning of streamDefault
 */
enum AttributeType {
  streamIn    = 1,
  streamOut   = 2,
  streamMulti = 4,
  attributeStream    = 8,
  attributeAttribute = 16,
  streamAsync = 32,
  streamDefault = 64
};

/**
 * The definition of an attribute and/or stream
 */
struct AttributeDef {
	string  name;
	string  type;
	AttributeType flags;
};

/**
 * InterfaceDef - interface definition structure
 *
 * defines what methods/attributes a particular interface supports: these
 * do not contain the methods/attributes of inherited interfaces.
 *
 * inheritedInterfaces only contains the names of Interfaces that this one
 * inherits in exactly one step. So to see if interface XYZ is inherited
 * from ABC, you need to check the "inheritedInterfaces" of XYZ, and their
 * "inheritedInterfaces" and their "inheritedInterfaces" and so on.
 *
 * - NB20000320: defaultPorts allows to connect to those port by default if
 *               connection is made in the corresponding direction.
 *               It cannot be just an attribute flag because of the syntax
 *               on a separate line.
 */

struct InterfaceDef {
	string name;

	sequence<string> inheritedInterfaces;
	sequence<MethodDef> methods;
	sequence<AttributeDef> attributes;
	
	sequence<string> defaultPorts;
};

// Type definitions (struct's and such)

/**
 * One component of a struct
 */
struct TypeComponent {
	string type;
	string name;
};

/**
 * The definition of a struct
 */
struct TypeDef {
	string name;

	sequence<TypeComponent> contents;
};

/**
 * One item of an enum value
 */
struct EnumComponent {
	string name;

	long value;
};

/**
 * The definition of an enum
 */
struct EnumDef {
	/**
	 * name if the enum, "_anonymous_" for anonymous enum - of course, when
	 * using namespaces, this can also lead to things like "Arts::_anonymous_",
	 * which would mean an anonymous enum in the Arts namespace
	 */
	string name;	

	sequence<EnumComponent> contents;
};

/**
 * The contents of an idl file
 */
struct ModuleDef {
	string moduleName;

	sequence<ModuleDef> modules;
	sequence<EnumDef> enums;
	sequence<TypeDef> types;
	sequence<InterfaceDef> interfaces;
};

/**
 * The interface repository
 */
interface InterfaceRepo {
	/**
	 * inserts the contents of a module into the interface repository
	 *
	 * @returns an ID which can be used to remove the entry again
	 */
	long insertModule(ModuleDef newModule);

	/**
	 * removes the contents of a module from the interface repository
	 */
	void removeModule(long moduleID);

	/**
	 * queries the definition of an interface
	 */
	InterfaceDef queryInterface(string name);

	/**
	 * queries the definition of a type
	 */
	TypeDef queryType(string name);
};

/**
 * Flow System interface
 */

/**
 * Internal use: implement distributed asynchronous streams.
 *
 * The FlowSystemSender object transmits the packets that should be sent
 * over the stream via _allocCustomMessage (Object_base).
 */
interface FlowSystemSender {
	/**
	 * This method is invoked whenever the receiver has finished processing
	 * a packet of the stream
	 */
	oneway void processed();
};

/**
 * Internal use: implement distributed asynchronous streams.
 *
 * The FlowSystemReceiver object receives and extracts the packets sent by
 * the sender object and injects them in the notification system again.
 */
interface FlowSystemReceiver {
	/**
	 * The custom message ID which should be used to send the stream packets
	 */
	readonly attribute long receiveHandlerID;
};

/**
 * A flow system.
 *
 * Flow systems handle the streaming between MCOP objects. As this streaming
 * is network transparent (at least for asynchronous streams) they have this
 * remote interface.
 */
interface FlowSystem {
	/**
	 * This starts a scheduling node
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void startObject(object node);

	/**
	 * This stops a scheduling node
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void stopObject(object node);

	/**
	 * This connects two objects, maybe even remote
	 *
	 * it is important that
	 *  - sourceObject/sourcePort points to the node the signal flow is
	 *    coming from
	 *  - destObject/destPort points to the node/port the signal flow is
	 *    going to
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void connectObject(object sourceObject, string sourcePort,
						object destObject, string destPort);

	/**
	 * This disconnects two objects, maybe even remote
	 *
	 * it is important that
	 * @li sourceObject/sourcePort points to the node the signal flow is
	 *     coming from
	 * @li destObject/destPort points to the node/port the signal flow is
	 *     going to
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void disconnectObject(object sourceObject, string sourcePort,
		 					object destObject, string destPort);

	/**
	 * queries the stream flags - returns 0 when such a stream isn't
	 * present
	 */
	AttributeType queryFlags(object node, string port);

	/**
	 * network transparent connections
	 */
	FlowSystemReceiver createReceiver(object destObject, string destPort,
												FlowSystemSender sender);
};

/**
 * A global communication space used to obtain initial object references
 *
 * MCOP needs a way to connect to initial (global) object references. This
 * is done by these global communication spaces.
 */
interface GlobalComm {
	/**
	 * puts a variable/value pair into the global communication
	 * space - it will not change the value of the variable if it is
	 * already present. Returns true if success, false if the variable
	 * was already there.
	 */
	boolean put(string variable, string value);

	/**
	 * gets the value of a variable out of the global communication
	 * space - it returns an empty string when the variable isn't there
	 */
	string get(string variable);

	/**
	 * removes a variable from the global communication space
	 */
	void erase(string variable);
};

/**
 * global communication based on the /tmp/mcop-<username> directory
 */
interface TmpGlobalComm : GlobalComm {
};

/* this is only (!) used for generation of the Object_stub stuff

interface Object {
	// access to the flow system this object is running in
	readonly attribute FlowSystem _flowSystem;

	// returns the ID for methodinvocations to this specific method
	long _lookupMethod(MethodDef methodDef);

	// returns the name of the interface
	string _interfaceName();

	// returns the interface description to a given interface
	InterfaceDef _queryInterface(string name);

	// returns the type description to a given type
	TypeDef _queryType(string name);

	// stringifies the object to one string
	string _toString();

	// prepares object for remote transmission (so that it will not be freed
	// soon, since the remote receiver expects it to be there after receiving
	// it)
	void _copyRemote();

	// declares that the object is used remotely now (do that only after
	// _copyRemote)
	void _useRemote();

	// declares that the object is no longer used remotely
	void _releaseRemote();
};

*/
