/*
    Copyright (C) 1999 Stefan Westerfeld
                       stefan@space.twc.de
  
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
  
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
  
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

// MCOP protocol

enum HeaderMagic { MCOP_MAGIC = 0x504f434d }; /* gets marshalled as "MCOP" */

enum MessageType {
 mcopInvocation  = 1,
 mcopReturn      = 2,
 mcopServerHello = 3,
 mcopClientHello = 4,
 mcopAuthAccept  = 5,
 mcopOnewayInvocation  = 6
};

struct Header {
    HeaderMagic magic;    // the value 0x504f434d, which is marshalled as MCOP
    long messageLength;
    MessageType messageType;
};

struct Invocation {
    long requestID;
    long objectID;
    long methodID;
};

struct OnewayInvocation {
    long objectID;
    long methodID;
};

struct ServerHello {
	string serverID;
	sequence<string> authProtocols;
	string authSeed;
};

struct ClientHello {
	string serverID;
	string authProtocol;
	string authData;
};

struct ObjectReference {
	string serverID; // should be unique, i.e. start time, hostname, and pid
	long objectID;	 // number of the object under that server
	sequence<string> urls; // where the server holding object can be reached
};

// Interface definitions

struct ParamDef {
	string type;
	string name;
};

/* Twoway methods are such where the calling process does a call and is
   suspended until some result (maybe even a void result) gets back.

   Oneway methods are one shot and forget methods: you send the invocation,
   and continue. Maybe it will be received, maybe executed later. You will
   never hear the result.
*/

enum MethodType {
	methodOneway = 1,
	methodTwoway = 2
};

struct MethodDef {
	string     name;
	string     type;
	MethodType flags;

	sequence<ParamDef> signature;
};

/*
 * an attribute
 *
 * flags should contain things like
 * - attribute is readonly/writeonly/readwrite
 * - attribute is incoming/outgoing stream
 * - if it's a stream, it also should contain the information whether it is
 *   asynchronous or synchronous
 * - NB20000320: see InterfaceDef for the meaning of streamDefault
 */

enum AttributeType {
  streamIn    = 1,
  streamOut   = 2,
  streamMulti = 4,
  attributeStream    = 8,
  attributeAttribute = 16,
  streamAsync = 32,
  streamDefault = 64
};

struct AttributeDef {
	string  name;
	string  type;
	AttributeType flags;
};

/**
 * InterfaceDef - interface definition structure
 *
 * defines what methods/attributes a particular interface supports: these
 * do not contain the methods/attributes of inherited interfaces.
 *
 * inheritedInterfaces only contains the names of Interfaces that this one
 * inherits in exactly one step. So to see if interface XYZ is inherited
 * from ABC, you need to check the "inheritedInterfaces" of XYZ, and their
 * "inheritedInterfaces" and their "inheritedInterfaces" and so on.
 *
 * - NB20000320: defaultPorts allows to connect to those port by default if
 *               connection is made in the corresponding direction.
 *               It cannot be just an attribute flag because of the syntax
 *               on a separate line.
 */

struct InterfaceDef {
	string name;

	sequence<string> inheritedInterfaces;
	sequence<MethodDef> methods;
	sequence<AttributeDef> attributes;
	
	sequence<string> defaultPorts;
};

// Type definitions (struct's and such)

struct TypeComponent {
	string type;
	string name;
};

struct TypeDef {
	string name;

	sequence<TypeComponent> contents;
};

struct EnumComponent {
	string name;

	long value;
};

struct EnumDef {
	string name;	// empty for anonymous enum

	sequence<EnumComponent> contents;
};

/**
 * The contents of an idl file
 */

struct ModuleDef {
	string moduleName;

	sequence<ModuleDef> modules;
	sequence<EnumDef> enums;
	sequence<TypeDef> types;
	sequence<InterfaceDef> interfaces;
};

/**
 * The interface repository
 */

interface InterfaceRepo {
	/**
	 * insertModule inserts the contents of a module into the interface
	 * repository and returns and ID
	 */
	long insertModule(ModuleDef newModule);

	/**
	 * removeModule removes the contents of a module from the interface
	 * repository
	 */
	void removeModule(long moduleID);

	/**
	 * queryInterface queries the definition of an interface
	 */
	InterfaceDef queryInterface(string name);

	/**
	 * queryType queries the definition of a type
	 */
	TypeDef queryType(string name);
};

/**
 * Flow System interface
 */

interface FlowSystemSender {
	oneway void processed();
};

interface FlowSystemReceiver {
	readonly attribute long receiveHandlerID;
	//oneway void receive(string packet);
};

interface FlowSystem {
	/**
	 * This starts a scheduling node
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void startObject(object node);

	/**
	 * This stops a scheduling node
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void stopObject(object node);

	/**
	 * This connects two objects, maybe even remote
	 *
	 * it is important that
	 *  - sourceObject/sourcePort points to the node the signal flow is
	 *    coming from
	 *  - destObject/destPort points to the node/port the signal flow is
	 *    going to
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void connectObject(object sourceObject, string sourcePort,
						object destObject, string destPort);

	/**
	 * This disconnects two objects, maybe even remote
	 *
	 * it is important that
	 *  - sourceObject/sourcePort points to the node the signal flow is
	 *    coming from
	 *  - destObject/destPort points to the node/port the signal flow is
	 *    going to
	 *
	 * Don't use this manually. Use object->_node()->connect(...) instead.
	 */
	void disconnectObject(object sourceObject, string sourcePort,
		 					object destObject, string destPort);

	/**
	 * queries the stream flags - returns 0 when such a stream isn't
	 * present
	 */
	AttributeType queryFlags(object node, string port);

	/**
	 * network transparent connections
	 */
	FlowSystemReceiver createReceiver(object destObject, string destPort,
												FlowSystemSender sender);
};

interface GlobalComm {
	/**
	 * put puts a variable/value pair into the global communication
	 * space - it will not change the value of the variable if it is
	 * already present. Returns true if success, false if the variable
	 * was already there.
	 */
	boolean put(string variable, string value);

	/**
	 * get gets the value of a variable out of the global communication
	 * space - it returns an empty string when the variable isn't there
	 */
	string get(string variable);

	/**
	 * erase removes a variable from the global communication space
	 */
	void erase(string variable);
};

/**
 * global communication based on the /tmp/mcop-<username> directory
 */
interface TmpGlobalComm : GlobalComm {
};

/* this is only (!) used for generation of the Object_stub stuff

interface Object {
	// access to the flow system this object is running in
	readonly attribute FlowSystem _flowSystem;

	// returns the ID for methodinvocations to this specific method
	long _lookupMethod(MethodDef methodDef);

	// returns the name of the interface
	string _interfaceName();

	// returns the interface description to a given interface
	InterfaceDef _queryInterface(string name);

	// returns the type description to a given type
	TypeDef _queryType(string name);

	// stringifies the object to one string
	string _toString();

	// prepares object for remote transmission (so that it will not be freed
	// soon, since the remote receiver expects it to be there after receiving
	// it)
	void _copyRemote();

	// declares that the object is used remotely now (do that only after
	// _copyRemote)
	void _useRemote();

	// declares that the object is no longer used remotely
	void _releaseRemote();
};

*/
