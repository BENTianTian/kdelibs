/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#ifndef CORE_H
#define CORE_H

#include "common.h"

enum HeaderMagic {MCOP_MAGIC = 1347371853};
enum MessageType {mcopInvocation = 1, mcopReturn = 2, mcopServerHello = 3, mcopClientHello = 4, mcopAuthAccept = 5};
enum AttributeType {streamIn = 1, streamOut = 2, streamMulti = 4, attributeStream = 8, attributeAttribute = 16};
class Header : public Type {
public:
	Header();
	Header(HeaderMagic magic, long messageLength, MessageType messageType);
	Header(Buffer& stream);
	Header(const Header& copyType);
	Header& operator=(const Header& assignType);
	virtual ~Header();

	HeaderMagic magic;
	long messageLength;
	MessageType messageType;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class Invocation : public Type {
public:
	Invocation();
	Invocation(long requestID, long objectID, long methodID);
	Invocation(Buffer& stream);
	Invocation(const Invocation& copyType);
	Invocation& operator=(const Invocation& assignType);
	virtual ~Invocation();

	long requestID;
	long objectID;
	long methodID;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ServerHello : public Type {
public:
	ServerHello();
	ServerHello(const string& serverID, const vector<string>& authProtocols, const string& authSeed);
	ServerHello(Buffer& stream);
	ServerHello(const ServerHello& copyType);
	ServerHello& operator=(const ServerHello& assignType);
	virtual ~ServerHello();

	string serverID;
	vector<string> authProtocols;
	string authSeed;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ClientHello : public Type {
public:
	ClientHello();
	ClientHello(const string& serverID, const string& authProtocol, const string& authData);
	ClientHello(Buffer& stream);
	ClientHello(const ClientHello& copyType);
	ClientHello& operator=(const ClientHello& assignType);
	virtual ~ClientHello();

	string serverID;
	string authProtocol;
	string authData;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ObjectReference : public Type {
public:
	ObjectReference();
	ObjectReference(const string& serverID, long objectID, const vector<string>& urls);
	ObjectReference(Buffer& stream);
	ObjectReference(const ObjectReference& copyType);
	ObjectReference& operator=(const ObjectReference& assignType);
	virtual ~ObjectReference();

	string serverID;
	long objectID;
	vector<string> urls;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ParamDef : public Type {
public:
	ParamDef();
	ParamDef(const string& type, const string& name);
	ParamDef(Buffer& stream);
	ParamDef(const ParamDef& copyType);
	ParamDef& operator=(const ParamDef& assignType);
	virtual ~ParamDef();

	string type;
	string name;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class MethodDef : public Type {
public:
	MethodDef();
	MethodDef(const string& name, const string& type, long flags, const vector<ParamDef *>& signature);
	MethodDef(Buffer& stream);
	MethodDef(const MethodDef& copyType);
	MethodDef& operator=(const MethodDef& assignType);
	virtual ~MethodDef();

	string name;
	string type;
	long flags;
	vector<ParamDef *> signature;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class AttributeDef : public Type {
public:
	AttributeDef();
	AttributeDef(const string& name, const string& type, AttributeType flags);
	AttributeDef(Buffer& stream);
	AttributeDef(const AttributeDef& copyType);
	AttributeDef& operator=(const AttributeDef& assignType);
	virtual ~AttributeDef();

	string name;
	string type;
	AttributeType flags;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class InterfaceDef : public Type {
public:
	InterfaceDef();
	InterfaceDef(const string& name, const vector<string>& inheritedInterfaces, const vector<MethodDef *>& methods, const vector<AttributeDef *>& attributes);
	InterfaceDef(Buffer& stream);
	InterfaceDef(const InterfaceDef& copyType);
	InterfaceDef& operator=(const InterfaceDef& assignType);
	virtual ~InterfaceDef();

	string name;
	vector<string> inheritedInterfaces;
	vector<MethodDef *> methods;
	vector<AttributeDef *> attributes;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class TypeComponent : public Type {
public:
	TypeComponent();
	TypeComponent(const string& type, const string& name);
	TypeComponent(Buffer& stream);
	TypeComponent(const TypeComponent& copyType);
	TypeComponent& operator=(const TypeComponent& assignType);
	virtual ~TypeComponent();

	string type;
	string name;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class TypeDef : public Type {
public:
	TypeDef();
	TypeDef(const string& name, const vector<TypeComponent *>& contents);
	TypeDef(Buffer& stream);
	TypeDef(const TypeDef& copyType);
	TypeDef& operator=(const TypeDef& assignType);
	virtual ~TypeDef();

	string name;
	vector<TypeComponent *> contents;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class EnumComponent : public Type {
public:
	EnumComponent();
	EnumComponent(const string& name, long value);
	EnumComponent(Buffer& stream);
	EnumComponent(const EnumComponent& copyType);
	EnumComponent& operator=(const EnumComponent& assignType);
	virtual ~EnumComponent();

	string name;
	long value;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class EnumDef : public Type {
public:
	EnumDef();
	EnumDef(const string& name, const vector<EnumComponent *>& contents);
	EnumDef(Buffer& stream);
	EnumDef(const EnumDef& copyType);
	EnumDef& operator=(const EnumDef& assignType);
	virtual ~EnumDef();

	string name;
	vector<EnumComponent *> contents;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ModuleDef : public Type {
public:
	ModuleDef();
	ModuleDef(const string& moduleName, const vector<ModuleDef *>& modules, const vector<EnumDef *>& enums, const vector<TypeDef *>& types, const vector<InterfaceDef *>& interfaces);
	ModuleDef(Buffer& stream);
	ModuleDef(const ModuleDef& copyType);
	ModuleDef& operator=(const ModuleDef& assignType);
	virtual ~ModuleDef();

	string moduleName;
	vector<ModuleDef *> modules;
	vector<EnumDef *> enums;
	vector<TypeDef *> types;
	vector<InterfaceDef *> interfaces;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class InterfaceRepo : virtual public Object {
public:
	static InterfaceRepo *_fromString(string objectref);

	virtual long insertModule(const ModuleDef& newModule) = 0;
	virtual void removeModule(long moduleID) = 0;
	virtual InterfaceDef* queryInterface(const string& name) = 0;
	virtual TypeDef* queryType(const string& name) = 0;
};

typedef ReferenceHelper<InterfaceRepo> InterfaceRepo_var;
class InterfaceRepo_stub : virtual public InterfaceRepo, virtual public Object_stub {
protected:
	InterfaceRepo_stub();

public:
	InterfaceRepo_stub(Connection *connection, long objectID);

	long insertModule(const ModuleDef& newModule);
	void removeModule(long moduleID);
	InterfaceDef* queryInterface(const string& name);
	TypeDef* queryType(const string& name);
};

class InterfaceRepo_skel : virtual public InterfaceRepo, virtual public Object_skel {
public:
	InterfaceRepo_skel();

	static string _interfaceNameSkel();
	string _interfaceName();
	void _buildMethodTable();
	void *_cast(string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#endif /* CORE_H */
