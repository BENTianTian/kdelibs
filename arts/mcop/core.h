/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#ifndef CORE_H
#define CORE_H

#include "common.h"

enum HeaderMagic {MCOP_MAGIC = 1347371853};
enum MessageType {mcopInvocation = 1, mcopReturn = 2, mcopServerHello = 3, mcopClientHello = 4, mcopAuthAccept = 5, mcopOnewayInvocation = 6};
enum MethodType {methodOneway = 1, methodTwoway = 2};
enum AttributeType {streamIn = 1, streamOut = 2, streamMulti = 4, attributeStream = 8, attributeAttribute = 16, streamAsync = 32};
class Header : public Type {
public:
	Header();
	Header(HeaderMagic magic, long messageLength, MessageType messageType);
	Header(Buffer& stream);
	Header(const Header& copyType);
	Header& operator=(const Header& assignType);
	virtual ~Header();

	HeaderMagic magic;
	long messageLength;
	MessageType messageType;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class Invocation : public Type {
public:
	Invocation();
	Invocation(long requestID, long objectID, long methodID);
	Invocation(Buffer& stream);
	Invocation(const Invocation& copyType);
	Invocation& operator=(const Invocation& assignType);
	virtual ~Invocation();

	long requestID;
	long objectID;
	long methodID;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class OnewayInvocation : public Type {
public:
	OnewayInvocation();
	OnewayInvocation(long objectID, long methodID);
	OnewayInvocation(Buffer& stream);
	OnewayInvocation(const OnewayInvocation& copyType);
	OnewayInvocation& operator=(const OnewayInvocation& assignType);
	virtual ~OnewayInvocation();

	long objectID;
	long methodID;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ServerHello : public Type {
public:
	ServerHello();
	ServerHello(const std::string& serverID, const std::vector<std::string>& authProtocols, const std::string& authSeed);
	ServerHello(Buffer& stream);
	ServerHello(const ServerHello& copyType);
	ServerHello& operator=(const ServerHello& assignType);
	virtual ~ServerHello();

	std::string serverID;
	std::vector<std::string> authProtocols;
	std::string authSeed;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ClientHello : public Type {
public:
	ClientHello();
	ClientHello(const std::string& serverID, const std::string& authProtocol, const std::string& authData);
	ClientHello(Buffer& stream);
	ClientHello(const ClientHello& copyType);
	ClientHello& operator=(const ClientHello& assignType);
	virtual ~ClientHello();

	std::string serverID;
	std::string authProtocol;
	std::string authData;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ObjectReference : public Type {
public:
	ObjectReference();
	ObjectReference(const std::string& serverID, long objectID, const std::vector<std::string>& urls);
	ObjectReference(Buffer& stream);
	ObjectReference(const ObjectReference& copyType);
	ObjectReference& operator=(const ObjectReference& assignType);
	virtual ~ObjectReference();

	std::string serverID;
	long objectID;
	std::vector<std::string> urls;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ParamDef : public Type {
public:
	ParamDef();
	ParamDef(const std::string& type, const std::string& name);
	ParamDef(Buffer& stream);
	ParamDef(const ParamDef& copyType);
	ParamDef& operator=(const ParamDef& assignType);
	virtual ~ParamDef();

	std::string type;
	std::string name;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class MethodDef : public Type {
public:
	MethodDef();
	MethodDef(const std::string& name, const std::string& type, MethodType flags, const std::vector<ParamDef *>& signature);
	MethodDef(Buffer& stream);
	MethodDef(const MethodDef& copyType);
	MethodDef& operator=(const MethodDef& assignType);
	virtual ~MethodDef();

	std::string name;
	std::string type;
	MethodType flags;
	std::vector<ParamDef *> signature;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class AttributeDef : public Type {
public:
	AttributeDef();
	AttributeDef(const std::string& name, const std::string& type, AttributeType flags);
	AttributeDef(Buffer& stream);
	AttributeDef(const AttributeDef& copyType);
	AttributeDef& operator=(const AttributeDef& assignType);
	virtual ~AttributeDef();

	std::string name;
	std::string type;
	AttributeType flags;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class InterfaceDef : public Type {
public:
	InterfaceDef();
	InterfaceDef(const std::string& name, const std::vector<std::string>& inheritedInterfaces, const std::vector<MethodDef *>& methods, const std::vector<AttributeDef *>& attributes);
	InterfaceDef(Buffer& stream);
	InterfaceDef(const InterfaceDef& copyType);
	InterfaceDef& operator=(const InterfaceDef& assignType);
	virtual ~InterfaceDef();

	std::string name;
	std::vector<std::string> inheritedInterfaces;
	std::vector<MethodDef *> methods;
	std::vector<AttributeDef *> attributes;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class TypeComponent : public Type {
public:
	TypeComponent();
	TypeComponent(const std::string& type, const std::string& name);
	TypeComponent(Buffer& stream);
	TypeComponent(const TypeComponent& copyType);
	TypeComponent& operator=(const TypeComponent& assignType);
	virtual ~TypeComponent();

	std::string type;
	std::string name;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class TypeDef : public Type {
public:
	TypeDef();
	TypeDef(const std::string& name, const std::vector<TypeComponent *>& contents);
	TypeDef(Buffer& stream);
	TypeDef(const TypeDef& copyType);
	TypeDef& operator=(const TypeDef& assignType);
	virtual ~TypeDef();

	std::string name;
	std::vector<TypeComponent *> contents;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class EnumComponent : public Type {
public:
	EnumComponent();
	EnumComponent(const std::string& name, long value);
	EnumComponent(Buffer& stream);
	EnumComponent(const EnumComponent& copyType);
	EnumComponent& operator=(const EnumComponent& assignType);
	virtual ~EnumComponent();

	std::string name;
	long value;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class EnumDef : public Type {
public:
	EnumDef();
	EnumDef(const std::string& name, const std::vector<EnumComponent *>& contents);
	EnumDef(Buffer& stream);
	EnumDef(const EnumDef& copyType);
	EnumDef& operator=(const EnumDef& assignType);
	virtual ~EnumDef();

	std::string name;
	std::vector<EnumComponent *> contents;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class ModuleDef : public Type {
public:
	ModuleDef();
	ModuleDef(const std::string& moduleName, const std::vector<ModuleDef *>& modules, const std::vector<EnumDef *>& enums, const std::vector<TypeDef *>& types, const std::vector<InterfaceDef *>& interfaces);
	ModuleDef(Buffer& stream);
	ModuleDef(const ModuleDef& copyType);
	ModuleDef& operator=(const ModuleDef& assignType);
	virtual ~ModuleDef();

	std::string moduleName;
	std::vector<ModuleDef *> modules;
	std::vector<EnumDef *> enums;
	std::vector<TypeDef *> types;
	std::vector<InterfaceDef *> interfaces;

// marshalling functions
	void readType(Buffer& stream);
	void writeType(Buffer& stream) const;
};

class InterfaceRepo_base : virtual public Object {
public:
	static InterfaceRepo_base *_create(const std::string& subClass = "InterfaceRepo");
	static InterfaceRepo_base *_fromString(std::string objectref);
	static InterfaceRepo_base *_fromReference(ObjectReference ref, bool needcopy);

	inline InterfaceRepo_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual long insertModule(const ModuleDef& newModule) = 0;
	virtual void removeModule(long moduleID) = 0;
	virtual InterfaceDef* queryInterface(const std::string& name) = 0;
	virtual TypeDef* queryType(const std::string& name) = 0;
};

typedef ReferenceHelper<InterfaceRepo_base> InterfaceRepo_var;

class InterfaceRepo_stub : virtual public InterfaceRepo_base, virtual public Object_stub {
protected:
	InterfaceRepo_stub();

public:
	InterfaceRepo_stub(Connection *connection, long objectID);

	long insertModule(const ModuleDef& newModule);
	void removeModule(long moduleID);
	InterfaceDef* queryInterface(const std::string& name);
	TypeDef* queryType(const std::string& name);
};

class InterfaceRepo_skel : virtual public InterfaceRepo_base, virtual public Object_skel {
public:
	InterfaceRepo_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	void _buildMethodTable();
	void *_cast(std::string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#include "reference.h"

class InterfaceRepo : virtual public SmartWrapper {
protected:
	InterfaceRepo_base *_InterfaceRepo_redirect;

	inline void _assign_InterfaceRepo_base(InterfaceRepo_base *base) {
		if(_InterfaceRepo_redirect != 0) _InterfaceRepo_redirect->_release();
		_InterfaceRepo_redirect = base;
		_autoCreate = false;
	}
virtual void _create() {
		_assign_InterfaceRepo_base(InterfaceRepo_base::_create());
	}
	inline InterfaceRepo_base *_InterfaceRepo_base() {
		if(_InterfaceRepo_redirect == 0 && _autoCreate) _create();  // lazy on-demand creation
		return _InterfaceRepo_redirect;	}
public:
	inline InterfaceRepo() : _InterfaceRepo_redirect(0) { /* nothing to be done*/ }
	inline virtual ~InterfaceRepo() { _assign_InterfaceRepo_base(0); }
	inline InterfaceRepo(const SubClass &s) : _InterfaceRepo_redirect(0) {
		_assign_InterfaceRepo_base(InterfaceRepo_base::_create(s.string()));
	}
	inline InterfaceRepo(const Reference &r) : _InterfaceRepo_redirect(0) {
		_assign_InterfaceRepo_base(r.isString()?(InterfaceRepo_base::_fromString(r.string())):(InterfaceRepo_base::_fromReference(r.reference(),true)));
	}
	inline InterfaceRepo(InterfaceRepo& target) : _InterfaceRepo_redirect(0) {
		_assign_InterfaceRepo_base(target._InterfaceRepo_base()->_copy());
	}
	inline InterfaceRepo& operator=(InterfaceRepo& target) {		_assign_InterfaceRepo_base(target._InterfaceRepo_base()->_copy());
		return *this;
	}
	inline InterfaceRepo(InterfaceRepo_base *target) : _InterfaceRepo_redirect(0) {
		_assign_InterfaceRepo_base(target->_copy());
	}
	inline InterfaceRepo& operator=(InterfaceRepo_base *target) {
		_assign_InterfaceRepo_base(target->_copy());
		return *this;
	}
	inline std::string toString() {return _InterfaceRepo_base()->_toString();}
	inline operator InterfaceRepo_base*() {return _InterfaceRepo_base();}
	inline bool isNull() {return _InterfaceRepo_base()==0;}

	inline long insertModule(const ModuleDef& newModule) {return _InterfaceRepo_base()->insertModule(newModule);}
	inline void removeModule(long moduleID) {return _InterfaceRepo_base()->removeModule(moduleID);}
	inline InterfaceDef* queryInterface(const std::string& name) {return _InterfaceRepo_base()->queryInterface(name);}
	inline TypeDef* queryType(const std::string& name) {return _InterfaceRepo_base()->queryType(name);}
};

class FlowSystemSender_base : virtual public Object {
public:
	static FlowSystemSender_base *_create(const std::string& subClass = "FlowSystemSender");
	static FlowSystemSender_base *_fromString(std::string objectref);
	static FlowSystemSender_base *_fromReference(ObjectReference ref, bool needcopy);

	inline FlowSystemSender_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual void processed() = 0;
};

typedef ReferenceHelper<FlowSystemSender_base> FlowSystemSender_var;

class FlowSystemSender_stub : virtual public FlowSystemSender_base, virtual public Object_stub {
protected:
	FlowSystemSender_stub();

public:
	FlowSystemSender_stub(Connection *connection, long objectID);

	void processed();
};

class FlowSystemSender_skel : virtual public FlowSystemSender_base, virtual public Object_skel {
public:
	FlowSystemSender_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	void _buildMethodTable();
	void *_cast(std::string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#include "reference.h"

class FlowSystemSender : virtual public SmartWrapper {
protected:
	FlowSystemSender_base *_FlowSystemSender_redirect;

	inline void _assign_FlowSystemSender_base(FlowSystemSender_base *base) {
		if(_FlowSystemSender_redirect != 0) _FlowSystemSender_redirect->_release();
		_FlowSystemSender_redirect = base;
		_autoCreate = false;
	}
virtual void _create() {
		_assign_FlowSystemSender_base(FlowSystemSender_base::_create());
	}
	inline FlowSystemSender_base *_FlowSystemSender_base() {
		if(_FlowSystemSender_redirect == 0 && _autoCreate) _create();  // lazy on-demand creation
		return _FlowSystemSender_redirect;	}
public:
	inline FlowSystemSender() : _FlowSystemSender_redirect(0) { /* nothing to be done*/ }
	inline virtual ~FlowSystemSender() { _assign_FlowSystemSender_base(0); }
	inline FlowSystemSender(const SubClass &s) : _FlowSystemSender_redirect(0) {
		_assign_FlowSystemSender_base(FlowSystemSender_base::_create(s.string()));
	}
	inline FlowSystemSender(const Reference &r) : _FlowSystemSender_redirect(0) {
		_assign_FlowSystemSender_base(r.isString()?(FlowSystemSender_base::_fromString(r.string())):(FlowSystemSender_base::_fromReference(r.reference(),true)));
	}
	inline FlowSystemSender(FlowSystemSender& target) : _FlowSystemSender_redirect(0) {
		_assign_FlowSystemSender_base(target._FlowSystemSender_base()->_copy());
	}
	inline FlowSystemSender& operator=(FlowSystemSender& target) {		_assign_FlowSystemSender_base(target._FlowSystemSender_base()->_copy());
		return *this;
	}
	inline FlowSystemSender(FlowSystemSender_base *target) : _FlowSystemSender_redirect(0) {
		_assign_FlowSystemSender_base(target->_copy());
	}
	inline FlowSystemSender& operator=(FlowSystemSender_base *target) {
		_assign_FlowSystemSender_base(target->_copy());
		return *this;
	}
	inline std::string toString() {return _FlowSystemSender_base()->_toString();}
	inline operator FlowSystemSender_base*() {return _FlowSystemSender_base();}
	inline bool isNull() {return _FlowSystemSender_base()==0;}

	inline void processed() {return _FlowSystemSender_base()->processed();}
};

class FlowSystemReceiver_base : virtual public Object {
public:
	static FlowSystemReceiver_base *_create(const std::string& subClass = "FlowSystemReceiver");
	static FlowSystemReceiver_base *_fromString(std::string objectref);
	static FlowSystemReceiver_base *_fromReference(ObjectReference ref, bool needcopy);

	inline FlowSystemReceiver_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual long receiveHandlerID() = 0;
};

typedef ReferenceHelper<FlowSystemReceiver_base> FlowSystemReceiver_var;

class FlowSystemReceiver_stub : virtual public FlowSystemReceiver_base, virtual public Object_stub {
protected:
	FlowSystemReceiver_stub();

public:
	FlowSystemReceiver_stub(Connection *connection, long objectID);

	long receiveHandlerID();
};

class FlowSystemReceiver_skel : virtual public FlowSystemReceiver_base, virtual public Object_skel {
public:
	FlowSystemReceiver_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	void _buildMethodTable();
	void *_cast(std::string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#include "reference.h"

class FlowSystemReceiver : virtual public SmartWrapper {
protected:
	FlowSystemReceiver_base *_FlowSystemReceiver_redirect;

	inline void _assign_FlowSystemReceiver_base(FlowSystemReceiver_base *base) {
		if(_FlowSystemReceiver_redirect != 0) _FlowSystemReceiver_redirect->_release();
		_FlowSystemReceiver_redirect = base;
		_autoCreate = false;
	}
virtual void _create() {
		_assign_FlowSystemReceiver_base(FlowSystemReceiver_base::_create());
	}
	inline FlowSystemReceiver_base *_FlowSystemReceiver_base() {
		if(_FlowSystemReceiver_redirect == 0 && _autoCreate) _create();  // lazy on-demand creation
		return _FlowSystemReceiver_redirect;	}
public:
	inline FlowSystemReceiver() : _FlowSystemReceiver_redirect(0) { /* nothing to be done*/ }
	inline virtual ~FlowSystemReceiver() { _assign_FlowSystemReceiver_base(0); }
	inline FlowSystemReceiver(const SubClass &s) : _FlowSystemReceiver_redirect(0) {
		_assign_FlowSystemReceiver_base(FlowSystemReceiver_base::_create(s.string()));
	}
	inline FlowSystemReceiver(const Reference &r) : _FlowSystemReceiver_redirect(0) {
		_assign_FlowSystemReceiver_base(r.isString()?(FlowSystemReceiver_base::_fromString(r.string())):(FlowSystemReceiver_base::_fromReference(r.reference(),true)));
	}
	inline FlowSystemReceiver(FlowSystemReceiver& target) : _FlowSystemReceiver_redirect(0) {
		_assign_FlowSystemReceiver_base(target._FlowSystemReceiver_base()->_copy());
	}
	inline FlowSystemReceiver& operator=(FlowSystemReceiver& target) {		_assign_FlowSystemReceiver_base(target._FlowSystemReceiver_base()->_copy());
		return *this;
	}
	inline FlowSystemReceiver(FlowSystemReceiver_base *target) : _FlowSystemReceiver_redirect(0) {
		_assign_FlowSystemReceiver_base(target->_copy());
	}
	inline FlowSystemReceiver& operator=(FlowSystemReceiver_base *target) {
		_assign_FlowSystemReceiver_base(target->_copy());
		return *this;
	}
	inline std::string toString() {return _FlowSystemReceiver_base()->_toString();}
	inline operator FlowSystemReceiver_base*() {return _FlowSystemReceiver_base();}
	inline bool isNull() {return _FlowSystemReceiver_base()==0;}

	long receiveHandlerID() {return _FlowSystemReceiver_base()->receiveHandlerID();}
};

class FlowSystem_base : virtual public Object {
public:
	static FlowSystem_base *_create(const std::string& subClass = "FlowSystem");
	static FlowSystem_base *_fromString(std::string objectref);
	static FlowSystem_base *_fromReference(ObjectReference ref, bool needcopy);

	inline FlowSystem_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual void startObject(Object_base * node) = 0;
	virtual void stopObject(Object_base * node) = 0;
	virtual void connectObject(Object_base * sourceObject, const std::string& sourcePort, Object_base * destObject, const std::string& destPort) = 0;
	virtual void disconnectObject(Object_base * sourceObject, const std::string& sourcePort, Object_base * destObject, const std::string& destPort) = 0;
	virtual AttributeType queryFlags(Object_base * node, const std::string& port) = 0;
	virtual FlowSystemReceiver_base * createReceiver(Object_base * destObject, const std::string& destPort, FlowSystemSender_base * sender) = 0;
};

typedef ReferenceHelper<FlowSystem_base> FlowSystem_var;

class FlowSystem_stub : virtual public FlowSystem_base, virtual public Object_stub {
protected:
	FlowSystem_stub();

public:
	FlowSystem_stub(Connection *connection, long objectID);

	void startObject(Object_base * node);
	void stopObject(Object_base * node);
	void connectObject(Object_base * sourceObject, const std::string& sourcePort, Object_base * destObject, const std::string& destPort);
	void disconnectObject(Object_base * sourceObject, const std::string& sourcePort, Object_base * destObject, const std::string& destPort);
	AttributeType queryFlags(Object_base * node, const std::string& port);
	FlowSystemReceiver_base * createReceiver(Object_base * destObject, const std::string& destPort, FlowSystemSender_base * sender);
};

class FlowSystem_skel : virtual public FlowSystem_base, virtual public Object_skel {
public:
	FlowSystem_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	void _buildMethodTable();
	void *_cast(std::string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#include "reference.h"

class FlowSystem : virtual public SmartWrapper {
protected:
	FlowSystem_base *_FlowSystem_redirect;

	inline void _assign_FlowSystem_base(FlowSystem_base *base) {
		if(_FlowSystem_redirect != 0) _FlowSystem_redirect->_release();
		_FlowSystem_redirect = base;
		_autoCreate = false;
	}
virtual void _create() {
		_assign_FlowSystem_base(FlowSystem_base::_create());
	}
	inline FlowSystem_base *_FlowSystem_base() {
		if(_FlowSystem_redirect == 0 && _autoCreate) _create();  // lazy on-demand creation
		return _FlowSystem_redirect;	}
public:
	inline FlowSystem() : _FlowSystem_redirect(0) { /* nothing to be done*/ }
	inline virtual ~FlowSystem() { _assign_FlowSystem_base(0); }
	inline FlowSystem(const SubClass &s) : _FlowSystem_redirect(0) {
		_assign_FlowSystem_base(FlowSystem_base::_create(s.string()));
	}
	inline FlowSystem(const Reference &r) : _FlowSystem_redirect(0) {
		_assign_FlowSystem_base(r.isString()?(FlowSystem_base::_fromString(r.string())):(FlowSystem_base::_fromReference(r.reference(),true)));
	}
	inline FlowSystem(FlowSystem& target) : _FlowSystem_redirect(0) {
		_assign_FlowSystem_base(target._FlowSystem_base()->_copy());
	}
	inline FlowSystem& operator=(FlowSystem& target) {		_assign_FlowSystem_base(target._FlowSystem_base()->_copy());
		return *this;
	}
	inline FlowSystem(FlowSystem_base *target) : _FlowSystem_redirect(0) {
		_assign_FlowSystem_base(target->_copy());
	}
	inline FlowSystem& operator=(FlowSystem_base *target) {
		_assign_FlowSystem_base(target->_copy());
		return *this;
	}
	inline std::string toString() {return _FlowSystem_base()->_toString();}
	inline operator FlowSystem_base*() {return _FlowSystem_base();}
	inline bool isNull() {return _FlowSystem_base()==0;}

	inline void startObject(Object_base * node) {return _FlowSystem_base()->startObject(node);}
	inline void stopObject(Object_base * node) {return _FlowSystem_base()->stopObject(node);}
	inline void connectObject(Object_base * sourceObject, const std::string& sourcePort, Object_base * destObject, const std::string& destPort) {return _FlowSystem_base()->connectObject(sourceObject, sourcePort, destObject, destPort);}
	inline void disconnectObject(Object_base * sourceObject, const std::string& sourcePort, Object_base * destObject, const std::string& destPort) {return _FlowSystem_base()->disconnectObject(sourceObject, sourcePort, destObject, destPort);}
	inline AttributeType queryFlags(Object_base * node, const std::string& port) {return _FlowSystem_base()->queryFlags(node, port);}
	inline FlowSystemReceiver_base * createReceiver(Object_base * destObject, const std::string& destPort, FlowSystemSender_base * sender) {return _FlowSystem_base()->createReceiver(destObject, destPort, sender);}
};

class GlobalComm_base : virtual public Object {
public:
	static GlobalComm_base *_create(const std::string& subClass = "GlobalComm");
	static GlobalComm_base *_fromString(std::string objectref);
	static GlobalComm_base *_fromReference(ObjectReference ref, bool needcopy);

	inline GlobalComm_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual bool put(const std::string& variable, const std::string& value) = 0;
	virtual std::string get(const std::string& variable) = 0;
	virtual void erase(const std::string& variable) = 0;
};

typedef ReferenceHelper<GlobalComm_base> GlobalComm_var;

class GlobalComm_stub : virtual public GlobalComm_base, virtual public Object_stub {
protected:
	GlobalComm_stub();

public:
	GlobalComm_stub(Connection *connection, long objectID);

	bool put(const std::string& variable, const std::string& value);
	std::string get(const std::string& variable);
	void erase(const std::string& variable);
};

class GlobalComm_skel : virtual public GlobalComm_base, virtual public Object_skel {
public:
	GlobalComm_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	void _buildMethodTable();
	void *_cast(std::string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#include "reference.h"

class GlobalComm : virtual public SmartWrapper {
protected:
	GlobalComm_base *_GlobalComm_redirect;

	inline void _assign_GlobalComm_base(GlobalComm_base *base) {
		if(_GlobalComm_redirect != 0) _GlobalComm_redirect->_release();
		_GlobalComm_redirect = base;
		_autoCreate = false;
	}
virtual void _create() {
		_assign_GlobalComm_base(GlobalComm_base::_create());
	}
	inline GlobalComm_base *_GlobalComm_base() {
		if(_GlobalComm_redirect == 0 && _autoCreate) _create();  // lazy on-demand creation
		return _GlobalComm_redirect;	}
public:
	inline GlobalComm() : _GlobalComm_redirect(0) { /* nothing to be done*/ }
	inline virtual ~GlobalComm() { _assign_GlobalComm_base(0); }
	inline GlobalComm(const SubClass &s) : _GlobalComm_redirect(0) {
		_assign_GlobalComm_base(GlobalComm_base::_create(s.string()));
	}
	inline GlobalComm(const Reference &r) : _GlobalComm_redirect(0) {
		_assign_GlobalComm_base(r.isString()?(GlobalComm_base::_fromString(r.string())):(GlobalComm_base::_fromReference(r.reference(),true)));
	}
	inline GlobalComm(GlobalComm& target) : _GlobalComm_redirect(0) {
		_assign_GlobalComm_base(target._GlobalComm_base()->_copy());
	}
	inline GlobalComm& operator=(GlobalComm& target) {		_assign_GlobalComm_base(target._GlobalComm_base()->_copy());
		return *this;
	}
	inline GlobalComm(GlobalComm_base *target) : _GlobalComm_redirect(0) {
		_assign_GlobalComm_base(target->_copy());
	}
	inline GlobalComm& operator=(GlobalComm_base *target) {
		_assign_GlobalComm_base(target->_copy());
		return *this;
	}
	inline std::string toString() {return _GlobalComm_base()->_toString();}
	inline operator GlobalComm_base*() {return _GlobalComm_base();}
	inline bool isNull() {return _GlobalComm_base()==0;}

	inline bool put(const std::string& variable, const std::string& value) {return _GlobalComm_base()->put(variable, value);}
	inline std::string get(const std::string& variable) {return _GlobalComm_base()->get(variable);}
	inline void erase(const std::string& variable) {return _GlobalComm_base()->erase(variable);}
};

class TmpGlobalComm_base : virtual public GlobalComm_base {
public:
	static TmpGlobalComm_base *_create(const std::string& subClass = "TmpGlobalComm");
	static TmpGlobalComm_base *_fromString(std::string objectref);
	static TmpGlobalComm_base *_fromReference(ObjectReference ref, bool needcopy);

	inline TmpGlobalComm_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

};

typedef ReferenceHelper<TmpGlobalComm_base> TmpGlobalComm_var;

class TmpGlobalComm_stub : virtual public TmpGlobalComm_base, virtual public GlobalComm_stub {
protected:
	TmpGlobalComm_stub();

public:
	TmpGlobalComm_stub(Connection *connection, long objectID);

};

class TmpGlobalComm_skel : virtual public TmpGlobalComm_base, virtual public GlobalComm_skel {
public:
	TmpGlobalComm_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	void _buildMethodTable();
	void *_cast(std::string interface);
	void dispatch(Buffer *request, Buffer *result,long methodID);
};

#include "reference.h"

class TmpGlobalComm : virtual public GlobalComm {
protected:
	TmpGlobalComm_base *_TmpGlobalComm_redirect;

	inline void _assign_TmpGlobalComm_base(TmpGlobalComm_base *base) {
		if(_TmpGlobalComm_redirect != 0) _TmpGlobalComm_redirect->_release();
		_TmpGlobalComm_redirect = base;
		_GlobalComm_redirect = base;
		_autoCreate = false;
	}
virtual void _create() {
		_assign_TmpGlobalComm_base(TmpGlobalComm_base::_create());
	}
	inline TmpGlobalComm_base *_TmpGlobalComm_base() {
		if(_TmpGlobalComm_redirect == 0 && _autoCreate) _create();  // lazy on-demand creation
		return _TmpGlobalComm_redirect;	}
public:
	inline TmpGlobalComm() : GlobalComm(), _TmpGlobalComm_redirect(0) { /* nothing to be done*/ }
	inline virtual ~TmpGlobalComm() { _assign_TmpGlobalComm_base(0); }
	inline TmpGlobalComm(const SubClass &s) : GlobalComm(), _TmpGlobalComm_redirect(0) {
		_assign_TmpGlobalComm_base(TmpGlobalComm_base::_create(s.string()));
	}
	inline TmpGlobalComm(const Reference &r) : GlobalComm(), _TmpGlobalComm_redirect(0) {
		_assign_TmpGlobalComm_base(r.isString()?(TmpGlobalComm_base::_fromString(r.string())):(TmpGlobalComm_base::_fromReference(r.reference(),true)));
	}
	inline TmpGlobalComm(TmpGlobalComm& target) : GlobalComm(), _TmpGlobalComm_redirect(0) {
		_assign_TmpGlobalComm_base(target._TmpGlobalComm_base()->_copy());
	}
	inline TmpGlobalComm& operator=(TmpGlobalComm& target) {		_assign_TmpGlobalComm_base(target._TmpGlobalComm_base()->_copy());
		return *this;
	}
	inline TmpGlobalComm(TmpGlobalComm_base *target) : GlobalComm(), _TmpGlobalComm_redirect(0) {
		_assign_TmpGlobalComm_base(target->_copy());
	}
	inline TmpGlobalComm& operator=(TmpGlobalComm_base *target) {
		_assign_TmpGlobalComm_base(target->_copy());
		return *this;
	}
	inline std::string toString() {return _TmpGlobalComm_base()->_toString();}
	inline operator TmpGlobalComm_base*() {return _TmpGlobalComm_base();}
	inline bool isNull() {return _TmpGlobalComm_base()==0;}

};

#endif /* CORE_H */
