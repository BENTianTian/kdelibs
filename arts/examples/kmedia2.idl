/*

This is just laying around here and waiting for somebody to start
implementing kmedia2. The MCOP IDL compiler now eats all required
expressions to idl this (enums, structs, attributes, interfaces).

NEW KMedia2 layout:
===================

KMedia1 itself doesn't play anything. Instead it has a backend for every
media type to play. It tells these backends: "start playing now", "stop
playing now" and similar things (using libmediatool). So there is a backend
for wave files, tacker files, midi files, etc., which all provide one
common interface.

The idea is to keep everything the old KMedia1 interface could do, but to
move to a new IPC architecture.

I'd suggest MCOP here. Why?

DCOP is a small protocol, which allows communcation between APPs. It is
intended specially to tell an application "the colorscheme has changed".

However, it doesn't offer possibilities like streaming. Of course, not
every KMedia2 object will need these, but some of them. The result will
be much nicer, if every of these objects can be treated in the standard
"flow graph" way, like other aRts objects can.

Another point is that DCOP is about applications, while MCOP is about
objects. In DCOP, you have a whole application, and the idea is that
you tell your application something. In MCOP, you have components, which
can be combined to applications.

The ultimate media player, which KMedia2 aims to be, should play midi,
video, audio, etc. It is about seeing a file, choosing a component which
might be able to decode it, and play it. So it is not about starting
the right application, but about loading the right component.

This gives you the advantage that you can for instance reuse components
even between quite different media types. It may for instance make sense
to reuse a reverb effect to play midi, audio and video files.

*/

enum poState {
  posPlaying,
  posFinished,
  posPaused
};

// use 2^n values here, since they can (should) be or'd together
enum poCapabilities {
  capSeek = 1,
  capPause = 2
};

struct poTime {
    long ms, seconds; // -1 if undefined
    float custom;     // some custom time unit (changed to float, is that ok?)
                      // -1 if undefined
    string customUnit; // for instance for a tracker "pattern"
};

interface PlayObject {
    attribute string description;
    attribute poTime currentTime;
    readonly attribute poTime overallTime;
    attribute poCapabilities capabilities;
    readonly attribute string mediaName;
    readonly attribute poState state;

    void play();
    void seek(poTime newTime); // could be handled by setting currentTime
    void pause();
};
