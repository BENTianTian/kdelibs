This is an approximation what remains todo to get aRts running on MCOP
as it was before on CORBA.

1. To get some kind of an audio server running

It does run. See kdelibs/arts/examples/artsd. However, there are a few
minor corrections missing to start to make it really useful for kde2.

These are:

- move required stuff
   => knotify should probably be in kdebase
- fix crash when playing wav files without libaudiofile installed

2. To get everything up again

- namespaces (mapped to modules in the IDL) - currently MCOP puts every
  interface in the standard namespace
- port visual objects
- do streaming between servers again
- more work on flow graph descriptions (Structure, etc.) -- external interfaces
- more work on dynamic N:M connectivity (SynthBus*)
- port artsbuilder
- port every object
- asynchronous streams (as opposed to synchronous) w/ language binding
- notifications when attributes change
- more work on streaming, for instance:
  - recursive scheduling again (with loops & cycles)
- reading/writing IEEE Floats needs proper documentation, testing on
  different architectures and probably different code for some machines
- more work on audio playing stuff (different sampling rates, different
  hardware, mono, tunable buffer sizes)
- make buffer sizes / samplingrate / depths / ... configurable
- rewrite resampling to work nicely on small blocks (instead of requiring
  the whole sample to be in memory). This in turn leads to
   - allow different sampling rates for artscat (make it work the same also
     regardless whether what samplingrate the server is running on)
   - allow progressive loading for wave files
- write blockwise caching (not requiring whole samples to be held in memory)
- someday implement a clever way how apps that are not written for aRts can
  use /dev/dsp nevertheless, maybe one of:
   - starting artsd only on demand
   - make artsd go to a sleep mode automatically if no clients are connected
   - make artsd go to a sleep mode after a timeout
   - make arts detect automatically when it is silent, and close /dev/dsp
     then (this would for instance also close if clients are connected but
     not playing anything)
   - make an explicit call like "shutdown now" (esdctl off/esdctl on)

3. To have more fun

- tune the transfer protocol (although MCOP theoretically could do 30000+
  synchronous invocations per second, it can only do 8000+)

  possible tuning operations are
    * rewrite Buffer not to use vector<char> to store data, but malloc'd
	  blocks
    * try to write "zero allocation" invocations, that means, try not to
	  allocate memory on performing an invocation. For instance Buffers
	  could be kept in pools, and be reused for further invocations, without
	  the need to realloc another memory block
    * try to minimize the amount of copies of data, possibly even using
	  something like sharedmem to share data between the sending and
	  receiving buffer

- implement plugins that transfer non-standard datatypes such as midi events,
  video frames, fft packets, oscilloscope views, ... (which was impossible
  with aRts on CORBA)
- make aRts run inside Brahms, KWave or your-favourite-other-app, to do
  signal processing where it is needed (similar to AudioLogic Environment,
  for instance)
- convince other people to use aRts, so that the usefulness of universal
  plugins written for the API increases
- when being crazy, implement gatewaying from MCOP to DCOP, CORBA, XMLRPC
  or whatever else might be useful

Other suggestions:

  => Config dialog:

- instead of using three radio buttons to select latency, use a slider
with three positions (left, middle, and right) with icons beneath them
depicting latency, or labels beneath these points.  More polished looking.

- instead of saying changes must take place when you logout and login,
just restart artsd after the dialog is accepted. (This may also be done
as an additional MCOP interface to change config stuff on the fly, as
restarting will mean that already connected clients (mp3 player) will
crash/hang).
