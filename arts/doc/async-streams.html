<HTML>
<TITLE>
Asynchronous streams in aRts
</TITLE>
<BODY bgcolor="#FFFFFF">
<h1>Using asynchronous streams in aRts</h1>
<p>
<h2>Sending data</h2>
<p>
Suppose you decided that you want to write a module to produce sound
asynchronously. Suppose its interface looks like that:
<pre>
interface SomeModule : SynthModule
{
    async out byte stream outdata;
};
</pre>
Fine. So how exactly do you send something now?
<p>
<h4>push delivery</h4>
<p>
With asynchronous streams you send the data as packets. That means, you send
individual packets with bytes in the above example. The actual process is:
allocate a packet, fill it, send it.
<p>
So step by step:
<ul>
<li>allocate a packet
<pre>
    DataPacket&lt;mcopbyte&gt; *packet = outdata.allocPacket(100);
</pre>
<li>fill it
<pre>
    // cast so that fgets is happy that it has a (char *) pointer
    char *data = (char *)packet-&gt;contents;

    // as you can see, you can shrink the packet size after allocation
    // if you like
    if(fgets(data,100,stdin))
        packet-&gt;size = strlen(data);
    else
        packet-&gt;size = 0;
</pre>
<li>send it
<pre>
    packet-&gt;send();                                                         
</pre>
</ul>
Pretty simple. But of course, if you want to send packets exactly as fast
as the receiver can process them, there needs to be another way.
<p>
<h4>pull delivery</h4>
<p>
That other way is pull delivery. You say: please, I want to send packets
as fast as the receiver is ready to process them. You start with a certain
amount of packets you send. And as the receiver processes one packet, and
another, you start refilling them with fresh data, and send them again.
<p>
You start that by calling setPull. So for instance
<pre>
    outdata.setPull(8, 1024);
</pre>
This means that you want to send packets over outdata. You want to start
sending 8 packets at once, and as the receiver processes some of them,
you want to refill these.
<p>
Then, you need to implement a method which fills the packets, which could
look like that:
<pre>
    void request_outdata(DataPacket&lt;mcopbyte&gt; *packet)
    {
        packet-&gt;size = 1024;  // shouldn't be more than 1024
        for(int i = 0;i &lt; 1024; i++)
            packet-&gt;contents[i] = (mcopbyte)'A';
        packet-&gt;send();
    }
</pre>
Thats it. When you don't have any data any more, you can start sending
packets with zero size, which will stop the pulling.
<p>
Its essential to call that method exactly request_&lt;streamname&gt;.
<p>
<h2>Receiving data</h2>
<p>
Thats much simpler. Suppose you have a simple ToLower filter, which simply
converts all letters in lowercase:
<pre>
interface ToLower {
    async in byte stream indata;
    async out byte stream outdata;
};
</pre>
Thats really simply to implement. Here is the whole implementation.
<pre>
class ToLower_impl : public ToLower_skel {
public:
    void process_indata(DataPacket&lt;mcopbyte&gt; *inpacket)
    {
        DataPacket&lt;mcopbyte&gt; *outpacket = outdata.allocPacket(inpacket-&gt;size);

        // convert to lowercase letters
        char *instring = (char *)inpacket-&gt;contents;
        char *outstring = (char *)outpacket-&gt;contents;

        for(int i=0;i&lt;inpacket-&gt;size;i++)
            outstring[i] = tolower(instring[i]);

        inpacket-&gt;processed();
        outpacket-&gt;send();
    }
};

REGISTER_IMPLEMENTATION(ToLower_impl);
</pre>
<p>
Again: its essential to call the method exactly process_&lt;streamname&gt;.
<p>
As you see, for each arriving packet you get a call for a function (the
process_indata call in our case). You need to call the processed() method
of a packet to indicate you have processed it.
<p>
Hint: if processing takes longer (i.e. if you need to wait for soundcard
output or something like that), don't call processed immediately, but
store the whole data packet and call processed only as soon as you really
processed that packet. That way, senders have a chance to know how long it
really takes to do your work.
<p>
As synchronization isn't so nice with asynchronous streams, you should use
synchronous streams whereever possible, and asynchronous streams only when
necessary.
<hr>
<a href=index.html>back to index</a>
</BODY>
</HTML>
