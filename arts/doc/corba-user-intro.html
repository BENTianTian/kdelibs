<HTML>
<TITLE>
Introduction to MCOP for CORBA users
</TITLE>
<BODY bgcolor="#FFFFFF">
<h1>Introduction to MCOP for CORBA users</h1>
<p>
When you were using CORBA before, you will see that MCOP is much the same
thing.
<p>
So the basic idea of CORBA remains: you implement objects (components). By
using the MCOP features, your objects are not only available as normal classes
from the same process (via standard C++ techniques) - they also are available
to remote servers.
<p>
Transparently. For this to work, the first thing you need to do is to specify
the interface of your objects in an IDL file - just like CORBA IDL. There are
only a few differences.
<p>
<h2>Differences in the IDL</h2>
<p>
<h3>Things that are missing against CORBA IDL</h3>
<ul>
<li>there are no "in" and "out" parameters on method invocations
<p>parameters are always incoming - the returncode is always outgoing, which
means that the interface
<pre>
// CORBA idl

interface Account {
  void deposit( in long amount );
  void withdraw( in long amount );
  long balance();
};                                                                              
</pre>
is written as
<pre>
// MCOP idl

interface Account {
  void deposit( long amount );
  void withdraw( long amount );
  long balance();
};
</pre>
in MCOP.
</p>
<li>no exception support
<p>MCOP doesn't have exceptions - use something else for error handling.</p>
<li>no union types, no typedefs
<p>I don't know if that is a real weakness - something one would despereately
need to survive.</p>
<li><b>currently unsupported</b> (expect this to be fixed some time)
<ul>
<li>no support for passing interfaces/object references
</ul>
</ul>
<h3>Things that are different against CORBA IDL</h3>
<ul>
<li>you declare sequences as sequence<[type]> in MCOP. No need to typedef.
<p>
Example:

instead of
<pre>
// CORBA idl

struct Line {
    long x1,y1,x2,y2;
};

typedef sequence&lt;Line&gt; LineSeq;

interface Plotter {
    void draw(in LineSeq lines);
};
</pre>
you write
<pre>
// MCOP idl

struct Line {
    long x1,y1,x2,y2;
};

interface Plotter {
    void draw(sequence&lt;Line&gt; lines);
};
</pre>
</p>
</ul>
<h3>Things that are new in MCOP IDL</h3>
<ul>
You can declare streams, which will then be evaluated by the aRts framework.
<p>
Streams are declared similar to attributes, for instance:
<pre>
// MCOP idl

interface Synth_ADD : SynthModule {
    in audio stream signal1,signal2;
    out audio stream outvalue;
};                                                                              
</pre>
This does say that your object will accept two incoming synchronous audio
streams, that are called signal1 and signal2.
<p>
By saying synchronous I mean: these are streams that deliver synchoneously
x samples per second (or other time), so that the scheduler will guarantee
to always provide you a balanced amount of input data (e.g. 200 samples of
signal1 are there and 200 samples signal2 are there).
<p>
You guarantee that if your object is called with those 200 samples
signal1 + signal2, it is able to produce exactly 200 samples outvalue - that
is what synchronous operation means.
</p>
</ul>
<h2>The MCOP C++ language binding</h2>
<p>
This differs from CORBA mostly. However here it is:
<h3>strings...</h3>
<p>
are using the C++ STL "string" class. When stored in sequences, they are
stored "plain", that means they are considered to be a primitive type. Thus,
they need copying.
</p>
<h3>longs...</h3>
<p>
are plain long's (expected to be 32 bit)
</p>
<h3>sequences...</h3>
<p>
are using the C++ STL "vector" class.
</p>
<h3>structures...</h3>
<p>
are all derived from the MCOP class "Type", and generated by the MCOP idl
compiler. When stored in sequences, they are not stored "plain", but as
pointers, as otherwise, too much copying would occur.
</p>

<h3> Implementing MCOP objects </h3>
<p>
After having them passed through the IDL compiler, you need to derive from
the _skel class. For instance, consider you have defined your interface
like that
</p>
<pre>
// MCOP idl: hello.idl

interface Hello {
    void hello(string s);
    string concat(string s1, string s2);
    long sum2(long a, long b);
};
</pre>
<p>
You pass that through the IDL compiler by calling "mcopidl hello.idl",
which will in turn generate hello.cc and hello.h.
</p>
To implement it, you need to define a C++-class that inherits the skeleton:
<p>
<pre>
// C++ header file - include hello.h somewhere

class Hello_impl : virtual public Hello_skel {
public:
    void hello(const string&amp; s);
    string concat(const string&amp; s1, const string&amp; s2);
    long sum2(long a, long b);
};
</pre>
Finally, you need to implement the methods as normal C++
<pre>
// C++ implementation file

// as you see string's are passed as const string references
void Hello_impl::hello(const string&amp; s)
{
    printf("Hello '%s'!\n",s.c_str());
}

// when they are a returncode they are passed as "normal" strings
string Hello_impl::concat(const string&amp; s1, const string&amp; s2)
{
    return s1+s2;
}

long Hello_impl::sum2(long a, long b)
{
    return a+b;
}
</p>
Once you did that, you have an object which can communicate using MCOP.
Just create one (using the normal C++ facilities to create an object)
<pre>
    Hello_impl server;
</pre>
And as soon as you give somebody the reference
<pre>
    string reference = server._toString();
    printf("%s\n",reference.c_str());
</pre>
and go to the MCOP idle loop
<pre>
Dispatcher::the()-&gt;run();
</pre>
People can access the thing using
<pre>
// this code can run anywhere - not necessarily in the same process
// (it may also run on a different computer/architecture)

    Hello *h = Hello::_fromString([the object reference printed above]);
</pre>
and invoke methods:
<pre>
    if(h)
        h-&gt;hello("test");
    else
        printf("Access failed?\n");
</pre>
<hr>
<a href=index.html>back to index</a>
</BODY>
</HTML>
