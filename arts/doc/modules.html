<HTML>
<TITLE>
aRts - about namespaces
</TITLE>
<BODY bgcolor="#EAEEEE">
<h1>Namespaces in aRts</h1>
<p>
<h2>Practical introduction</h2>
<p>
Each namespace declaration corresponds to a "module" declaration in the MCOP
idl.
<p>
<pre>
// mcop idl

module M {
    interface A
    {
    }
};

interface B;
</pre>
In this case, the generated C++ code for the IDL snippet would look like that:
<pre>
// C++ header

namespace M {
    /* declaration of A_base/A_skel/A_stub and similar */
    class A {        // Smartwrapped reference class
        /* [...] */
    };
}

/* declaration of B_base/B_skel/B_stub and similar */
class B {
    /* [...] */
};
</pre>
<p>
So when referring the classes from the above example in your C++ code, you
would have to write M::A, but only B. However, you can of course use "using M"
somewhere - like with any namespace in C++.
<p>
<h2>How aRts uses namespaces</h2>
<p>
There is one global namespace called "Arts", which all programs and libraries
that belong to aRts itself use to put their declarations in. This means, that
when writing C++ code that depends on aRts, you normally have to prefix every
class you use with Arts::, like this:
<pre>
int main(int argc, char **argv)
{
    Arts::Dispatcher dispatcher;
    Arts::SimpleSoundServer server(Arts::Reference("global:Arts_SimpleSoundServer"));

    server.play("/var/foo/somefile.wav");
</pre>
The other alternative is to write a using once, like this:
<pre>
using namespace Arts;

int main(int argc, char **argv)
{
    Dispatcher dispatcher;
    SimpleSoundServer server(Reference("global:Arts_SimpleSoundServer"));

    server.play("/var/foo/somefile.wav");
    [...]
</pre>
<p>
In IDL files, you don't exactly have a choice. If you are writing code that
belongs to aRts itself, you'll have to put it into module Arts.
<p>
<pre>
// IDL File for aRts code:
#include &lt;artsflow.idl&gt;

module Arts {        // put it into the Arts namespace
    interface Synth_TWEAK : SynthModule
    {
        in audio stream invalue;
        out audio stream outvalue;
        attribute float tweakFactor;
    };
};
</pre>
If you write code that doesn't belong to aRts itself, you should not put it
into the Arts namespace. However, you can make an own namespace if you like.
<p>
In any case, you'll have to prefix classes you use from aRts.
<pre>
// IDL File for code which doesn't belong to aRts:
#include &lt;artsflow.idl&gt;

// either write without module declaration, then the generated classes will
// not use a namespace:
interface Synth_TWEAK2 : Arts::SynthModule
{
    in audio stream invalue;
    out audio stream outvalue;
    attribute float tweakFactor;
};

// however, you can also choose your own namespace, if you like, so if you
// write an application "PowerRadio", you could for instance do it like this:
module PowerRadio {
    struct Station {
        string name;
        float frequency;
    };

    interface Tuner : Arts::SynthModule {
        attribute Station station;     // no need to prefix Station, same module
        out audio stream left, right;
    };
};
</pre>
<p>
<h2>Internals: How the implementation works</h2>
<p>
Often, in interfaces, casts, method signatures and similar, MCOP needs to
refer to names of types or interfaces. These are represented as string in
the common MCOP datastructures, while the namespace is always fully
represented in the C++ style. This means the strings would contain "M::A"
and "B", following the example above.
<p>
Note this even applies if inside the IDL text the namespace qualifiers were
not given, since the context made clear which namespace the interface "A"
was meant to be used in.
<p>
<hr>
<a href=index.html>back to index</a>
</BODY>
</HTML>
