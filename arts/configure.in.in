dnl aRts specific configure tests
dnl
dnl libaudiofile is used for loading wave files

AC_DEFUN(AC_CHECK_LIBAUDIOFILE,
[
  ac_ldflags_save="$LDFLAGS"
  ac_CPPFLAGS_save="$CPPFLAGS"
  LDFLAGS="$all_libraries $LDFLAGS"
  CPPFLAGS="$CPPFLAGS $all_includes"
  arts_audiolib_found=no
  dnl WAV reading
  AC_LANG_SAVE
  AC_LANG_C
  AC_CHECK_HEADER(audiofile.h,
  [
    AC_CHECK_LIB(audiofile,afOpenFile,[
      dnl LDFLAGS in case it's in KDEDIR/lib
      LIBAUDIOFILE="$LDFLAGS -laudiofile"
      AC_DEFINE(HAVE_LIBAUDIOFILE, 1,
        [Define if you have libaudiofile (required for playing wavs with aRts)])
      arts_audiolib_found=yes
    ])
  ])
  AM_CONDITIONAL(HAVE_WAVSUPPORT,  test "x$arts_audiolib_found" = "xyes")
  AC_SUBST(LIBAUDIOFILE)
  AC_LANG_RESTORE
  CPPFLAGS="$ac_CPPFLAGS_save"
  LDFLAGS="$ac_ldflags_save"
])

dnl Posix realtime scheduling - this is helpful if you want arts to run with
dnl higher priority than everthing else

AC_DEFUN(AC_CHECK_REALTIME_SCHED,
[
AC_MSG_CHECKING([for posix realtime scheduling support])
AC_CACHE_VAL(ac_cv_realtime_sched,
[
AC_TRY_LINK([
#include <sched.h>
],
[
sched_getscheduler(0);
],
ac_cv_realtime_sched=yes,
ac_cv_realtime_sched=no)
])
AC_MSG_RESULT($ac_cv_realtime_sched)
if eval "test \"`echo `$ac_cv_realtime_sched\" = yes"; then
  AC_DEFINE(HAVE_REALTIME_SCHED,1,
        [Define if your system supports realtime scheduling])
fi
])

dnl Type of the ioctl function test - after some tries, it seems that this
dnl not required for Linux vs. FreeBSD (for which this test was written), and
dnl that only the Linux documentation claims that it has an "int" as second
dnl argument. But maybe there will pop up systems for which the signature
dnl differs, later.

AC_DEFUN(AC_CHECK_IOCTL_TYPE,
[
  AC_MSG_CHECKING([ioctl type])
  AC_CACHE_VAL(ac_cv_ioctl_type,
  [
    AC_LANG_SAVE
    AC_LANG_C

    AC_TRY_COMPILE(
    [
      #include <sys/ioctl.h>
	  int ioctl(int d, int request,...);
    ],
    [
    ],
	ac_cv_ioctl_type=1)
    AC_TRY_COMPILE(
    [
      #include <sys/ioctl.h>
	  int ioctl(int d, unsigned long request,...);
    ],
    [
    ],
	ac_cv_ioctl_type=2)
    AC_TRY_COMPILE(
    [
      #include <sys/ioctl.h>
	  int ioctl(int d, unsigned long int request,...);
    ],
    [
    ],
	ac_cv_ioctl_type=3)
     AC_LANG_RESTORE
  ])
  AC_MSG_RESULT($ac_cv_ioctl_type)
  

if test $ac_cv_ioctl_type = 1; then
  AC_DEFINE(HAVE_IOCTL_INT_INT_DOTS,1,
	      [Define if ioctl is declared as int ioctl(int d, int request,...)])
fi
if test $ac_cv_ioctl_type = 2; then
  AC_DEFINE(HAVE_IOCTL_INT_ULONG_DOTS,2,
	      [Define if ioctl is declared as int ioctl(int d, unsigned long request,...)])
fi
if test $ac_cv_ioctl_type = 3; then
  AC_DEFINE(HAVE_IOCTL_INT_ULONGINT_DOTS,3,
	      [Define if ioctl is declared as int ioctl(int d, unsigned long int request,...)])
fi
])

dnl check whether we can do rouding using asm optimization

AC_DEFUN(AC_CHECK_X86_FLOAT_INT,
[
AC_MSG_CHECKING([for x86 float to int conversions])
AC_CACHE_VAL(ac_cv_x86_float_int,
[
AC_TRY_LINK([
static inline long QRound (float inval)
{
  long ret;
  asm ("fistpl %0" : "=m" (ret) : "t" (inval) : "st");
  return ret;
}
],
[
long i = QRound(41.93);  /* should be 42 */
],
ac_cv_x86_float_int=yes,
ac_cv_x86_float_int=no)
])
AC_MSG_RESULT($ac_cv_x86_float_int)
if eval "test \"`echo `$ac_cv_x86_float_int\" = yes"; then
  AC_DEFINE(HAVE_X86_FLOAT_INT,1,
        [Define if you want to use optimized x86 float to int conversion code])
fi
])

dnl check whether we should try to emulate stdio fopen/fclose via
dnl glibc facilities (this *really* depends on glibc internals)

AC_DEFUN(AC_CHECK_ARTSDSP_STDIO_EMU,
[
AC_MSG_CHECKING([for stdio emulation in artsdsp])
AC_CACHE_VAL(ac_cv_artsdsp_stdio_emu,
[
AC_LANG_SAVE
AC_LANG_C
AC_TRY_LINK([
#define _GNU_SOURCE
#include <stdio.h>
],
[
	cookie_io_functions_t fns = { 0, 0, 0, 0 };
	struct fd_cookie *fdc = 0;
	FILE *out = fopencookie (fdc,"w", fns);
	out->_fileno = 0;
],
ac_cv_artsdsp_stdio_emu=yes,
ac_cv_artsdsp_stdio_emu=no)
])
AC_LANG_RESTORE
AC_MSG_RESULT($ac_cv_artsdsp_stdio_emu)
if eval "test \"`echo `$ac_cv_artsdsp_stdio_emu\" = yes"; then
  AC_DEFINE(HAVE_ARTSDSP_STDIO_EMU,1,
	[Define if you want to use glibc facilities to emulate stdio accesses in artsdsp])
fi
])
                                                                      
dnl call the tests

AC_CHECK_LIBAUDIOFILE
AC_CHECK_REALTIME_SCHED
AC_CHECK_GETDOMAINNAME
AC_CHECK_IOCTL_TYPE
AC_CHECK_X86_FLOAT_INT
AC_CHECK_ARTSDSP_STDIO_EMU
KDE_CHECK_THREADING

arts_with_alsa=yes
AC_ARG_WITH(alsa, [  --with-alsa             enable aRts ALSA support],
[arts_with_alsa=$withval])

if test "$arts_with_alsa" = "yes"; then
AC_DEFUN(AC_CHECK_LIBASOUND,
[
  ac_ldflags_save="$LDFLAGS"
  LDFLAGS="$all_libraries $LDFLAGS"
  AC_CHECK_HEADER(sys/asoundlib.h,
  [
    AC_CHECK_LIB(asound,snd_seq_create_simple_port,[
      alsa=true
      LIBASOUND="-lasound"
      AC_DEFINE(HAVE_LIBASOUND, 1,
        [Define if you have libasound (required for alsa support)])
    ], [
      alsa=false
    ])
  ])
  AC_SUBST(LIBASOUND)
  LDFLAGS="$ac_ldflags_save"
])
AC_CHECK_LIBASOUND
fi

AC_SUBST(LIBASOUND)
 

dnl Don't remove !
dnl AC_OUTPUT(arts/artsc/artsc-config)

dnl Don't remove !
dnl AC_OUTPUT(arts/artsc/artsdsp)

MCOPIDL='$(top_builddir)/arts/mcopidl/mcopidl'
AC_SUBST(MCOPIDL)

