    /*

    Copyright (C) 2000 Stefan Westerfeld
                       stefan@space.twc.de

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.
  
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
   
    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.

    */

/*
 * arts.idl - MCOP port. What's missing currently in MCOP?
 *
 * -   namespaces (module)
 */

//module Arts {  // analog real time synthesizer
	/*
	 * incoming or outgoing port?
	 */
	enum PortDirection {input, output};

	/*
	 * DataType: currently, creating new data types requires recompiling
	 *   everything - but there will eventually be a self describing
	 *   data type
	 *
	 *  audio_data = float data
	 * string_data = string data
	 */
	enum PortDataType {audio_data, string_data};

	/*
	 * ConnType: (connection type) this is wether this value is used
	 *
	 * - once (such as a filename of a waveplugin)  -> property
	 *   this implies that the allowed connection is only value
	 *
	 * - event based (such as midi events)          -> event
	 *   when events arrive, they are processed, when no events arrive,
	 *	 don't care
	 *
	 * - stream based (such as audio streams)       -> stream
	 *   every calculation of the module consumes/creates a sample
     *   that means: no data = no calculation possible
	 */ 
	enum PortConnType { conn_stream, conn_event, conn_property};

	/*
	 * isMultiPort specifies if the port can take multiple incoming
	 * connections or not. This is only relevant/allowed for input ports,
	 * the output of all output ports may be connected to any amount of
	 * receivers.
	 *
	 * Ports which can take multiple connections are handled differently
	 * internally. (Also, artsbuilder needs to know whether to allow multi-
	 * connections or not).
	 */

	struct PortType {
		PortDirection Direction;
		PortDataType DataType;
		PortConnType ConnType;
		boolean isMultiPort;
	};

	// Description of a synthesis port within a ModuleDesc

	struct PortDesc {
		// ID is guaranteed to be unique in the structure the port belongs to
		long ID;

		// Name is guaranteed to be unique for each module (no two in/out-
		// ports with the same name allowed)
		string Name;
		PortType Type;

		/*
		 * - for input channels, one of those must be true (only event
		 *   channels may remain unconnected),
		 * - for output channels, only isConnected may be set
		 *
		 * only one of them may be set, not both
		 */

		boolean isConnected;
		boolean hasValue;	// set to false is only allowed writing

		// connections, used when isConnected is true
		//readonly attribute PortDescSeq Connections;
		sequence<long> ConnectedIDs;

		// to be used as const value when hasValue is true
		float  FloatValue;
		string StringValue;

		//readonly attribute long internalOldID;
	};

	// Description of a synthesis module within a structure
	// (ports, screen position)

	struct ModuleDesc {
		// ID is guaranteed to be unique in the structure the module belongs to
		long ID;

		string Name;
		sequence<PortDesc> Ports;
		long X, Y, Width, Height;
		boolean isInterface, isStructure;
	};

	// Description of a synthesis structure
	//
	// this is the kind of object ArtsBuilder edits visually

	struct StructureDesc {
		// the width & height of the structure
		long Width, Height;
		sequence<ModuleDesc> Modules;
		//StructurePortDescSeq Ports;

		// for
		//  - publishing
		//  - using structures as modules again
		//readonly attribute ModuleInfo ExternalInterface;
		string Name;
		// this is to enable faster execution of structures without
		// substructures (the execution algorithm then knows that it doesn't
		// need to expand them)
		boolean containsStructures;
	};

	interface ArtsServer {
		// ID is guaranteed to be unique between servers which publish on one
		// broker
		// fixme: readonly attribute long ID;

		long createModules();
		boolean createModule(long mid, ModuleDesc desc);
		boolean localConnectModules(long mid);

		// fixme: boolean remoteConnectModules(long mid, long remotemid, sequence<ModuleDesc> remotemodules, ArtsServer remoteserver);

		boolean finalizeModules(long mid);
		void startModules(long mid);
		void deleteModules(long mid);

		// fixme: void requestSignal(in long mid, in long portid, in Receiver receiver);

		//--- session management --------------------------------------------

		/*
		 * Each server should be able to save the user tuneable parameters
		 * of a session to a sequence of strings (which may in turn be
		 * written to a file or similar).
		 *
		 * It should also produce a list of structure IDs that are related
		 * to that session, so that it can be restored later.
		 */
		// fixme: boolean saveSessionModules(in long mid, out StringSeq data,
		//								 out IDSeq structureIDs);

		/*
		 * When restoring, the server will get the data from the saved
		 * session first.
		 *
		 * When restoring modules, it may happen that some of them require
		 * that other structures are running (so they shall be restored as
		 * well). For instance, a mixer may require one structure per
		 * channel running. 
		 *
		 * To do so, the modules may call restoreStructure, passing the
		 * restoreID they got from restoreSessionModules, and the old ID
		 * the structure once had (before being saved).
		 */
		// fixme: boolean restoreSessionModules(in long mid, in StringSeq data,
		//													in long restoreID);
	};

	/**
	 * this interface contains the components of the old "Synthesizer"
	 * interface that are related to execution of structures
	 */
	interface ExecutionManager {
		// resets the synthesizer when halted (see Status)
		// void Reset();
		// Status getStatus();

		// normally use this before execution to expand the structure
		// (replace the modules that are implemented through a substructure
		// by their "simple" components)
		StructureDesc expandStructureDesc(StructureDesc structuredesc);

		// returns the identifier with which the structure modules can be
		// removed again;   id != 0: success
		long createStructure(StructureDesc structuredesc);
                               // in ArtsServerSeq preferredservers

		// whether a structure is still executing
		boolean isExecuting(long id);

		// free a structure again
		boolean freeStructure(long id);

		// hack to get the server down even if reference counting or other
		// things have failed don't use in "normal" operation

		void forceTermination();
	};
//};

/**
 * new stuff (introduced in the MCOP version of aRts, done differently before)
 */

enum AutoSuspendState { asNoSuspend, asSuspend, asSuspendStop };

interface SynthModule {
	// interface for users of this module

	/**
	 * This function starts the streaming (e.g. the module will start
	 * producing samples) - if you write a module, do not reimplement this,
	 * instead reimplement streamInit/streamStart
	 */
	void start();

	/**
	 * This function stops the streaming - if you write a plugin, do not
	 * reimplement this, instead reimplement streamEnd
	 */
	void stop();

	// interface for people implementing modules

	/**
	 * this is supposed to be the initialization every module passes after
	 * all attributes have been set up (e.g. you can see which file to open,
	 * how to initialize your filter coefficients or whatever)
	 */
	void streamInit();

	/**
	 * starts the I/O of the module
	 */
	void streamStart();
	/*
	long readfd();
	long writefd();
	*/

	/**
	 * stop the thing again, and free data possibly allocated in streamInit
	 */
	void streamEnd();

	/**
	 * autosuspend
	 *
	 * If you run a mixer desk (without anything connected), no calculations
	 * need to be done - since the output is silent anyway. For this reason,
	 * there exists this autosuspend attribute. It has three possible values:
	 *
	 *   asNoSuspend - this one is appropriate when you have a module that
	 *                 is active by itself
	 *   asSuspend   - this one is appropriate for modules that "do nothing"
	 *                 by themselves
	 *   asSuspendStop - this one is for modules that should be stopped, when
	 *                 the system gets suspended, and restarted when the
	 *                 system will start again - an example for this is
	 *                 soundcard output
	 *
	 * A module should choose asSuspend (or asSuspendStop) only if the
	 * following conditions are true:
	 *
	 *  - given constant inputs (like 3.0 on all ports), the module will
	 *    give constant output after some time
	 *  - given only 0.0 inputs, the module will give only 0.0 outputs
	 *    after some time
	 *  - the module does not synchronize itself through signal flow (i.e.
	 *    a midi sequence which "knows" when a second has passed through
	 *    the signal flow breaks when suspension happens)
	 *  - the module can't be brought to do something with a method
	 *    invocation (i.e. a module which starts generating noise for
	 *    a second whenever the noise() method is called is not suspendable)
	 *  - the module has no internal state that changes over time when only
	 *    constant inputs are given
	 *
	 * Typical examples for suspendable modules are arithmetic operations,
	 * filters, delay/hall/reverb, soundcard output.
	 *
	 * Typical examples for non-suspendable modules are sequences, midi stuff,
	 * soundcard input (isn't constant even when nothing else happens),
	 * oscillators, sample players,...
	 */
	readonly attribute AutoSuspendState autoSuspend;
};

interface Synth_PLAY : SynthModule {
	// attribute string channels;
	default in audio stream invalue_left,invalue_right;
};

interface Synth_FREQUENCY : SynthModule {
	in audio stream frequency;
	out audio stream pos;
};

interface Synth_WAVE_SIN : SynthModule {
	in audio stream pos;
	out audio stream outvalue;
};

interface Synth_MULTI_ADD : SynthModule {
	in multi audio stream invalue;
	out audio stream outvalue;
};

interface Synth_ADD : SynthModule {
	default in audio stream invalue1,invalue2;
	out audio stream outvalue;
};

interface Synth_MUL : SynthModule {
	in audio stream invalue1,invalue2;
	out audio stream outvalue;
	default invalue1, invalue2;
};

interface Synth_PLAY_WAV : SynthModule {
	attribute float speed;
	attribute string filename;
	readonly attribute boolean finished;

	out audio stream left, right;
	default left, right;
};

interface ByteStreamToAudio : SynthModule {
	attribute long samplingRate;
	attribute long channels;
	attribute long bits;

	/**
	 * is conversion currently running, or is it stalled due to the fact
	 * that there is not enough input input?
	 */
	readonly attribute boolean running;

	async in byte stream indata;

	out audio stream left,right;
	default left;
	default right;
};

interface StereoEffect : SynthModule {
	default in audio stream inleft, inright;
	default out audio stream outleft, outright;
};

/*
 * this is a simple clipping stereo volume control
 */
interface StereoVolumeControl : StereoEffect {
	attribute float scaleFactor;
	readonly attribute float currentVolumeLeft;
	readonly attribute float currentVolumeRight;
};

/*
 * this is a funny fft scope
 */
interface StereoFFTScope : StereoEffect {
	readonly attribute sequence<float> scope;
};

interface StereoEffectStack : SynthModule {
	/*
	   these should be streams - however dynamic expansion isn't there
	   yet, so this is the quick & dirty solution
	 */
	void setInputs(object leftObj, string leftPort,
					object rightObj, string rightPort);
	void setOutputs(object leftObj, string leftPort,
					object rightObj, string rightPort);

	long insertTop(StereoEffect effect, string name);
	long insertBottom(StereoEffect effect, string name);

	void remove(long ID);
};
