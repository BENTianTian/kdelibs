	/*

	Copyright (C) 1998-1999 Stefan Westerfeld
                            stefan@space.twc.de

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

    */

/*
 * arts.idl - MCOP port. What's missing currently in MCOP?
 *
 * -   namespaces (module)
 */

//module Arts {  // analog real time synthesizer
	/*
	 * incoming or outgoing port?
	 */
	enum PortDirection {input, output};

	/*
	 * DataType: currently, creating new data types requires recompiling
	 *   everything - but there will eventually be a self describing
	 *   data type
	 *
	 *  audio_data = float data
	 * string_data = string data
	 */
	enum PortDataType {audio_data, string_data};

	/*
	 * ConnType: (connection type) this is wether this value is used
	 *
	 * - once (such as a filename of a waveplugin)  -> property
	 *   this implies that the allowed connection is only value
	 *
	 * - event based (such as midi events)          -> event
	 *   when events arrive, they are processed, when no events arrive,
	 *	 don't care
	 *
	 * - stream based (such as audio streams)       -> stream
	 *   every calculation of the module consumes/creates a sample
     *   that means: no data = no calculation possible
	 */ 
	enum PortConnType { conn_stream, conn_event, conn_property};

	/*
	 * isMultiPort specifies if the port can take multiple incoming
	 * connections or not. This is only relevant/allowed for input ports,
	 * the output of all output ports may be connected to any amount of
	 * receivers.
	 *
	 * Ports which can take multiple connections are handled differently
	 * internally. (Also, artsbuilder needs to know whether to allow multi-
	 * connections or not).
	 */

	struct PortType {
		PortDirection Direction;
		PortDataType DataType;
		PortConnType ConnType;
		boolean isMultiPort;
	};

	// Description of a synthesis port within a ModuleDesc

	struct PortDesc {
		// ID is guaranteed to be unique in the structure the port belongs to
		long ID;

		// Name is guaranteed to be unique for each module (no two in/out-
		// ports with the same name allowed)
		string Name;
		PortType Type;

		/*
		 * - for input channels, one of those must be true (only event
		 *   channels may remain unconnected),
		 * - for output channels, only isConnected may be set
		 *
		 * only one of them may be set, not both
		 */

		boolean isConnected;
		boolean hasValue;	// set to false is only allowed writing

		// connections, used when isConnected is true
		//readonly attribute PortDescSeq Connections;
		sequence<long> ConnectedIDs;

		// to be used as const value when hasValue is true
		float  FloatValue;
		string StringValue;

		//readonly attribute long internalOldID;
	};

	// Description of a synthesis module within a structure
	// (ports, screen position)

	struct ModuleDesc {
		// ID is guaranteed to be unique in the structure the module belongs to
		long ID;

		string Name;
		sequence<PortDesc> Ports;
		long X, Y, Width, Height;
		boolean isInterface, isStructure;
	};

	// Description of a synthesis structure
	//
	// this is the kind of object ArtsBuilder edits visually

	struct StructureDesc {
		// the width & height of the structure
		long Width, Height;
		sequence<ModuleDesc> Modules;
		//StructurePortDescSeq Ports;

		// for
		//  - publishing
		//  - using structures as modules again
		//readonly attribute ModuleInfo ExternalInterface;
		string Name;
		// this is to enable faster execution of structures without
		// substructures (the execution algorithm then knows that it doesn't
		// need to expand them)
		boolean containsStructures;
	};

	interface ArtsServer {
		// ID is guaranteed to be unique between servers which publish on one
		// broker
		// fixme: readonly attribute long ID;

		long createModules();
		boolean createModule(long mid, ModuleDesc desc);
		boolean localConnectModules(long mid);

		// fixme: boolean remoteConnectModules(long mid, long remotemid, sequence<ModuleDesc> remotemodules, ArtsServer remoteserver);

		boolean finalizeModules(long mid);
		void startModules(long mid);
		void deleteModules(long mid);

		// fixme: void requestSignal(in long mid, in long portid, in Receiver receiver);

		//--- session management --------------------------------------------

		/*
		 * Each server should be able to save the user tuneable parameters
		 * of a session to a sequence of strings (which may in turn be
		 * written to a file or similar).
		 *
		 * It should also produce a list of structure IDs that are related
		 * to that session, so that it can be restored later.
		 */
		// fixme: boolean saveSessionModules(in long mid, out StringSeq data,
		//								 out IDSeq structureIDs);

		/*
		 * When restoring, the server will get the data from the saved
		 * session first.
		 *
		 * When restoring modules, it may happen that some of them require
		 * that other structures are running (so they shall be restored as
		 * well). For instance, a mixer may require one structure per
		 * channel running. 
		 *
		 * To do so, the modules may call restoreStructure, passing the
		 * restoreID they got from restoreSessionModules, and the old ID
		 * the structure once had (before being saved).
		 */
		// fixme: boolean restoreSessionModules(in long mid, in StringSeq data,
		//													in long restoreID);
	};

	/**
	 * this interface contains the components of the old "Synthesizer"
	 * interface that are related to execution of structures
	 */
	interface ExecutionManager {
		// resets the synthesizer when halted (see Status)
		// void Reset();
		// Status getStatus();

		// normally use this before execution to expand the structure
		// (replace the modules that are implemented through a substructure
		// by their "simple" components)
		StructureDesc expandStructureDesc(StructureDesc structuredesc);

		// returns the identifier with which the structure modules can be
		// removed again;   id != 0: success
		long createStructure(StructureDesc structuredesc);
                               // in ArtsServerSeq preferredservers

		// whether a structure is still executing
		boolean isExecuting(long id);

		// free a structure again
		boolean freeStructure(long id);

		// hack to get the server down even if reference counting or other
		// things have failed don't use in "normal" operation

		void forceTermination();
	};
//};

/**
 * new stuff (introduced in the MCOP version of aRts, done differently before)
 */

interface SynthModule {
	/**
	 * this initialization is called before anything is done with the module
	 */
	void firstInitialize();

	/**
	 * this is supposed to be the initialization every module passes after
	 * all attributes have been set up (e.g. you can see which file to open,
	 * how to initialize your filter coefficients or whatever)
	 */
	void initialize();

	/**
	 * starts the I/O of the module
	 */
	void start();
	/*
	long readfd();
	long writefd();
	*/

	/**
	 * stop the thing again
	 */
	void deInitialize();
};

interface Synth_PLAY : SynthModule {
	// attribute string channels;
	in audio stream invalue_left,invalue_right;
};

interface Synth_FREQUENCY : SynthModule {
	in audio stream frequency;
	out audio stream pos;
};

interface Synth_WAVE_SIN : SynthModule {
	in audio stream pos;
	out audio stream outvalue;
};

interface Synth_MULTI_ADD : SynthModule {
	in multi audio stream invalue;
	out audio stream outvalue;
};

interface Synth_ADD : SynthModule {
	in audio stream invalue1,invalue2;
	out audio stream outvalue;
};

interface Synth_MUL : SynthModule {
	in audio stream invalue1,invalue2;
	out audio stream outvalue;
};

interface Synth_PLAY_WAV : SynthModule {
	attribute float speed;
	attribute string filename;
	readonly attribute boolean finished;

	out audio stream left, right;
};

interface ByteStreamToAudio : SynthModule {
	attribute long samplingRate;
	attribute long channels;
	attribute long bits;

	async in byte stream indata;

	out audio stream left,right;
};

interface StereoEffect : SynthModule {
	in audio stream inleft, inright;
	out audio stream outleft, outright;
};

/*
 * this is a simple clipping stereo volume control
 */
interface StereoVolumeControl : StereoEffect {
	attribute float scaleFactor;
	readonly attribute float currentVolumeLeft;
	readonly attribute float currentVolumeRight;
};

interface StereoEffectStack : SynthModule {
	/*
	   these should be streams - however dynamic expansion isn't there
	   yet, so this is the quick & dirty solution
	 */
	void setInputs(object leftObj, string leftPort,
					object rightObj, string rightPort);
	void setOutputs(object leftObj, string leftPort,
					object rightObj, string rightPort);

	long insertTop(StereoEffect effect, string name);
	long insertBottom(StereoEffect effect, string name);

	void remove(long ID);
};
