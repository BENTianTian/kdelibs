/*
*   Copyright (C) 2008 Nicola Gigante <nicola.gigante@gmail.com>
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the
*   Free Software Foundation, Inc.,
*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA .
*/

#ifndef ACTION_REPLY_H
#define ACTION_REPLY_H

#include <QString>
#include <QVariant>
#include <QMap>
#include <QDataStream>

class ActionReplyPrivate;

/**
* @brief Class that encapsulates a reply coming from the helper after executing an action
*
* An instance of ActionReply is returned every time you execute an action with the Action
* class. You get the reply directly from the Action::execute() method or indirectly as
* a parameter of the ActionWatcher::actionPerformed() signal.
*
* ActionReply objects can contain both data from a successful action or an error indicator.
* In case of success, the errorCode() is ActionReply::NoError (zero) and the type() is
* ActionReply::Success. The data() method returns a QVariantMap object that may contain
* custom data sent back by the helper.
*
* In case of errors coming from the library, the type() is ActionReply::KAuthError. In this
* case, errorCode() will always be one of the predefined errors from the ActionReply::Error enum.
* An error reply of KAuthError type always contains an empty data() object. For some kind of errors
* you could get a human-readable description with errorDescription().
*
* If, instead, the helper itself has to report some errors occurred during the action execution,
* the type() will be (and has to be) ActionReply::HelperError. In this case the data() object can
* contain custom data from the helper, and the errorCode() and errorDescription() values are
* application-dependent.
*
* In the helper, to create an action reply object you have two choices: using the constructor, or
* the predefined replies. For example, to create a successful reply you can use the default constructor
* but to create an helper error reply, instead of writing <i>ActionReply(ActionReply::HelperError)</i>
* you could use the more convenient <i>ActionReply::HelperErrorReply</i> constant.
*
* You should not use the predefined error replies to create and return new errors. Replies with the
* KAuthError type are intended to be returned by the library only. However, you can use them for
* comparisons.
*
* To quickly check for success or failure of an action, you can use succeded() or failed().
*/
class ActionReply
{
    ActionReplyPrivate *d;

public:
    /**
     * Enumeration of the different kinds of replies.
     */
    enum Type {
        KAuthError, ///< An error reply generated by the library itself.
        HelperError, ///< An error reply generated by the helper.
        Success ///< The action has been completed successfully
    };

    static const ActionReply SuccessReply; ///< An empty successful reply. Same as using the default constructor
    static const ActionReply HelperErrorReply; ///< An empty reply with type() == HelperError.

    static const ActionReply NoResponderReply; ///< errorCode() == NoResponder
    static const ActionReply NoSuchActionReply; ///< errorCode() == NoSuchAction
    static const ActionReply AuthorizationDeniedReply; ///< errorCode() == AuthorizationDenied
    static const ActionReply UserCancelledReply; ///< errorCode() == UserCancelled
    static const ActionReply HelperBusyReply; ///< errorCode() == HelperBusy
    static const ActionReply DBusErrorReply; ///< errorCode() == DBusError

    /**
     * The enumeration of the possible values of errorCode() when type() is ActionReply::KAuthError
     */
    enum Error {
        NoError = 0, ///< No error.
        NoResponder, ///< The helper responder object hasn't been set. This shouldn't happen if you use the KDE4_AUTH_HELPER macro in the helper source
        NoSuchAction, ///< The action you tried to execute doesn't exist.
        AuthorizationDenied, ///< You don't have the authorization to execute the action
        UserCancelled, ///< Action execution has been cancelled by the user
        HelperBusy, ///< The helper is busy executing another action (or group of actions). Try later
        DBusError ///< An error from dbus occurred
    };

    /// Default constructor. Sets type() to Success and errorCode() to zero.
    ActionReply();

    /**
     * @brief Constructor to directly set the type.
     *
     * This constructor directly set the reply type. You shouldn't need to
     * directly call this constructor, because you can use the more convenient
     * predefined replies constants. You also shouldn't create a reply with
     * the KAuthError type because it's reserved for errors coming from the
     * library.
     *
     * @param type The type of the new reply
     */
    ActionReply(Type type);

    /**
     * @brief Constructor that creates a KAuthError reply with a specified error code.
     *        Do not use outside the library.
     *
     * This constructor is for internal use only, since it creates a reply
     * with KAuthError type, which is reserved for errors coming from the library.
     *
     * @param errorCode The error code of the new reply
     */
    ActionReply(int errorCode);

    /// Copy constructor
    ActionReply(const ActionReply &reply);

    /// Virtual destructor
    virtual ~ActionReply();

    /**
     * @brief Return the custom data coming from the helper.
     *
     * This method is used to get the data coming from the helper.
     * The meaning of this data is totally application-dependent.
     * In replies of type KAuthError, this object is always empty.
     *
     * If you are writing the helper, set the data using the object
     * obtained by this method. The return value is a reference, so
     * as with Action::arguments(), it's convenient to do things like:
     * @code
     * reply.data()["key"] = value;
     * @endcode
     * @return The data coming from (or that will be sent by) the helper
     */
    QVariantMap &data();

    /**
     * @brief Return the custom data coming from the helper.
     *
     * This is the same as the other data(), but the return type is not a reference
     * and the method is const, if you have to call it on a const ActionReply &.
     *
     * @return The data coming from (or that will be sent by) the helper
     */
    QVariantMap data() const;

    /// Returns the reply's type
    Type type() const;

    /**
     * @brief Sets the reply type
     *
     * Every time you create an action reply, you implicitly set a type.
     * Default constructed replies or ActionReply::SuccessReply have
     * type() == Success.
     * ActionReply::HelperErrorReply has type() == HelperError.
     * Predefined error replies have type() == KAuthError.
     *
     * This means you rarely need to change the type after the creation,
     * but if you need to, don't set it to KAuthError, because it's reserved
     * for errors coming from the library.
     *
     * @param type The new reply type
     */
    void setType(Type type);

    /// Returns true if type() == Success
    bool succeded() const;

    /// Returns true if type() != Success
    bool failed() const;

    /**
     * @brief Returns the error code of an error reply
     *
     * The error code returned is one of the values in the ActionReply::Error
     * enumeration if type() == KAuthError, or is totally application-dependent if
     * type() == HelperError. It also should be zero for successful replies.
     *
     * @return The reply error code
     */
    int errorCode() const;

    /**
     * @brief Sets the error code of an error reply
     *
     * If you're setting the error code in the helper because
     * you need to return an error to the application, please make sure
     * you already have set the type to HelperError, either by calling
     * setType() or by creating the reply in the right way.
     *
     * If the type is Success when you call this method, it will become KAuthError
     *
     * @param errorCode The new reply error code
     */
    void setErrorCode(int errorCode);

    /**
     * @brief Gets a human-readble description of the error, if available
     *
     * Currently, replies of type KAuthError rarely report an error description.
     * This situation could change in the future.
     *
     * By now, you can use this method for custom errors of type HelperError.
     *
     * @return The error human-readable description
     */
    QString errorDescription() const;

    /**
     * @brief Sets a human-readble description of the error
     *
     * Call this method from the helper if you want to send back a description for
     * a custom error. Note that this method doesn't affect the errorCode in any way
     *
     * @param error The new error description
     */
    void setErrorDescription(const QString &error);

    /**
     * @brief Serialize the reply into a QByteArray.
     *
     * This is a conveniece method used internally to sent the reply to a remote peer.
     * To recreate the reply, use deserialize()
     *
     * @return A QByteArray rapresentation of this reply
     */
    QByteArray serialized() const;

    /**
     * @brief Deserialize a reply from a QByteArray
     *
     * This method returns a reply from a QByteArray obtained from
     * the serialized() method.
     *
     * @param data A QByteArray obtained with serialized()
     */
    static ActionReply deserialize(QByteArray data);

    /// Assignment operator
    ActionReply &operator=(const ActionReply &reply);

    /**
     * @brief Comparison operator
     *
     * This operator checks if the type and the error code of two replies are the same.
     * It <b>doesn't</b> compare the data or the error descriptions, so be careful.
     *
     * The suggested use it to compare a reply agains one of the predefined error replies:
     * @code
     * if(reply == ActionReply::HelperBusyReply)
     * {
     *    // Do something...
     * }
     * @endcode
     *
     * Note that you can do it also by compare errorCode() with the relative enumeration value.
     */
    bool operator==(const ActionReply &reply);

    /**
     * @brief Negated comparison operator
     *
     * See the operator==() for an important notice.
     */
    bool operator!=(const ActionReply &reply);

    /// Output streaming operator for QDataStream
    friend QDataStream &operator<<(QDataStream &, const ActionReply &);

    /// Input streaming operator for QDataStream
    friend QDataStream &operator>>(QDataStream &, ActionReply &);

};

#endif
